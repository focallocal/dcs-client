{"version":3,"file":"comToPlugin.js","sources":["../node_modules/bellhop-iframe/src/BellhopEventDispatcher.js","../node_modules/bellhop-iframe/src/Bellhop.js","../src/utils.js","../src/comToPlugin.js"],"sourcesContent":["/**\n * Function with a added priority type\n * @typedef {Function} PriorityFunction\n * @property {number} _priority\n */\n\n/**\n * Generic event dispatcher\n * @class  BellhopEventDispatcher\n */\nexport class BellhopEventDispatcher {\n  /**\n   *  The collection of event listeners\n   *  @property {Object} _listeners\n   *  @private\n   */\n  constructor() {\n    this._listeners = {};\n  }\n\n  /**\n   *  Add an event listener to the listen to an event from either the parent or iframe\n   *  @method on\n   *  @param {String} name The name of the event to listen\n   *  @param {PriorityFunction} callback The handler when an event is triggered\n   *  @param {number} [priority=0] The priority of the event listener. Higher numbers are handled first.\n   */\n  on(name, callback, priority = 0) {\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    callback._priority = parseInt(priority) || 0;\n\n    // If callback is already set to this event\n    if (-1 !== this._listeners[name].indexOf(callback)) {\n      return;\n    }\n\n    this._listeners[name].push(callback);\n\n    if (this._listeners[name].length > 1) {\n      this._listeners[name].sort(this.listenerSorter);\n    }\n  }\n\n  /**\n   * @private\n   * @param {PriorityFunction} a\n   * @param {PriorityFunction} b\n   * @returns {number};\n   *  Sorts listeners added by .on() by priority\n   */\n  listenerSorter(a, b) {\n    return a._priority - b._priority;\n  }\n\n  /**\n   *  Remove an event listener\n   *  @method off\n   *  @param {String} name The name of event to listen for. If undefined, remove all listeners.\n   *  @param {Function} [callback] The optional handler when an event is triggered, if no callback\n   *         is set then all listeners by type are removed\n   */\n  off(name, callback) {\n    if (this._listeners[name] === undefined) {\n      return;\n    }\n\n    if (callback === undefined) {\n      delete this._listeners[name];\n      return;\n    }\n\n    const index = this._listeners[name].indexOf(callback);\n\n    -1 < index ? this._listeners[name].splice(index, 1) : undefined;\n  }\n\n  /**\n   *  Trigger any event handlers for an event type\n   *  @method trigger\n   *  @param {object | String} event The event to send\n   *  @param {object} [data = {}] optional data to send to other areas in the app that are listening for this event\n   */\n  trigger(event, data = {}) {\n    if (typeof event == 'string') {\n      event = {\n        type: event,\n        data: 'object' === typeof data && null !== data ? data : {}\n      };\n    }\n\n    if ('undefined' !== typeof this._listeners[event.type]) {\n      for (let i = this._listeners[event.type].length - 1; i >= 0; i--) {\n        this._listeners[event.type][i](event);\n      }\n    }\n  }\n\n  /**\n   * Reset the listeners object\n   * @method  destroy\n   */\n  destroy() {\n    this._listeners = {};\n  }\n}\n","import { BellhopEventDispatcher } from './BellhopEventDispatcher.js';\n\n/**\n *  Abstract the communication layer between the iframe\n *  and the parent DOM\n *  @class Bellhop\n *  @extends BellhopEventDispatcher\n */\nexport class Bellhop extends BellhopEventDispatcher {\n  /**\n   * Creates an instance of Bellhop.\n   * @memberof Bellhop\n   * @param { string | number } id the id of the Bellhop instance\n   */\n  constructor(id = (Math.random() * 100) | 0) {\n    super();\n\n    /**\n     *  The instance ID for bellhop\n     *  @property {string} id\n     */\n    this.id = `BELLHOP:${id}`;\n    /**\n     *  If we are connected to another instance of the bellhop\n     *  @property {Boolean} connected\n     *  @readOnly\n     *  @default false\n     *  @private\n     */\n    this.connected = false;\n\n    /**\n     *  If this instance represents an iframe instance\n     *  @property {Boolean} isChild\n     *  @private\n     *  @default true\n     */\n    this.isChild = true;\n\n    /**\n     *  If we are current trying to connec\n     *  @property {Boolean} connecting\n     *  @default false\n     *  @private\n     */\n    this.connecting = false;\n\n    /**\n     *  If using cross-domain, the domain to post to\n     *  @property {string} origin\n     *  @private\n     *  @default \"*\"\n     */\n    this.origin = '*';\n\n    /**\n     *  Save any sends to wait until after we're done\n     *  @property {Array} _sendLater\n     *  @private\n     */\n    this._sendLater = [];\n\n    /**\n     * The iframe element\n     * @property {HTMLIFrameElement} iframe\n     * @private\n     * @readOnly\n     */\n    this.iframe = null;\n\n    /**\n     * The bound receive function\n     * @property {Function} receive\n     * @private\n     */\n    this.receive = this.receive.bind(this);\n  }\n\n  /**\n   *  The connection has been established successfully\n   *  @event connected\n   */\n\n  /**\n   *  Connection could not be established\n   *  @event failed\n   */\n\n  /**\n   *  Handle messages in the window\n   *  @method receive\n   *  @param { MessageEvent } message the post message received from another bellhop instance\n   *  @private\n   */\n  receive(message) {\n    // Ignore messages that don't originate from the target\n    // we're connected to\n    if (this.target !== message.source) {\n      return;\n    }\n\n    // If this is not the initial connection message\n    if (message.data !== 'connected') {\n      let data = message.data;\n      // Check to see if the data was sent as a stringified json\n      if ('string' === typeof data) {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          console.error('Bellhop error: ', err);\n        }\n      }\n      if (this.connected && 'object' === typeof data && data.type) {\n        this.trigger(data);\n      }\n      return;\n    }\n    // Else setup the connection\n    this.onConnectionReceived(message.data);\n  }\n  /**\n   * @memberof Bellhop\n   * @param {object} message the message received from the other bellhop instance\n   * @private\n   */\n  onConnectionReceived(message) {\n    this.connecting = false;\n    this.connected = true;\n\n    // Be polite and respond to the child that we're ready\n    if (!this.isChild) {\n      this.target.postMessage(message, this.origin);\n    }\n\n    // If we have any sends waiting to send\n    // we are now connected and it should be okay\n    for (let i = 0; i < this._sendLater.length; i++) {\n      const { type, data } = this._sendLater[i];\n      this.send(type, data);\n    }\n    this._sendLater.length = 0;\n\n    // If there is a connection event assigned call it\n    this.trigger('connected');\n  }\n\n  /**\n   *  Setup the connection\n   *  @method connect\n   *  @param {HTMLIFrameElement} iframe The iframe to communicate with. If no value is set, the assumption\n   *         is that we're the child trying to communcate with our window.parent\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\n   *  @return {Bellhop} Return instance of current object\n   */\n  connect(iframe, origin = '*') {\n    // Ignore if we're already trying to connect\n    if (this.connecting) {\n      return;\n    }\n\n    // Disconnect from any existing connection\n    this.disconnect();\n\n    // We are trying to connect\n    this.connecting = true;\n\n    // The iframe if we're the parent\n    if (iframe instanceof HTMLIFrameElement) {\n      this.iframe = iframe;\n    }\n\n    // The instance of bellhop is inside the iframe\n    this.isChild = iframe === undefined;\n\n    this.supported = true;\n    if (this.isChild) {\n      // for child pages, the window passed must be a different window\n      this.supported = window != iframe;\n    }\n\n    this.origin = origin;\n\n    window.addEventListener('message', this.receive);\n\n    if (this.isChild) {\n      // No parent, can't connect\n      if (window === this.target) {\n        this.trigger('failed');\n      } else {\n        // If connect is called after the window is ready\n        // we can go ahead and send the connect message\n        this.target.postMessage('connected', this.origin);\n      }\n    }\n  }\n\n  /**\n   *  Disconnect if there are any open connections\n   *  @method disconnect\n   */\n  disconnect() {\n    this.connected = false;\n    this.connecting = false;\n    this.origin = null;\n    this.iframe = null;\n    this.isChild = true;\n    this._sendLater.length = 0;\n\n    window.removeEventListener('message', this.receive);\n  }\n\n  /**\n   *  Send an event to the connected instance\n   *  @method send\n   *  @param {string} type name/type of the event\n   *  @param {*} [data = {}] Additional data to send along with event\n   */\n  send(type, data = {}) {\n    if (typeof type !== 'string') {\n      throw 'The event type must be a string';\n    }\n\n    const message = {\n      type,\n      data\n    };\n\n    if (this.connecting) {\n      this._sendLater.push(message);\n    } else {\n      this.target.postMessage(JSON.stringify(message), this.origin);\n    }\n  }\n\n  /**\n   *  A convenience method for sending and the listening to create\n   *  a singular link to fetching data. This is the same calling send\n   *  and then getting a response right away with the same event.\n   *  @method fetch\n   *  @param {String} event The name of the event\n   *  @param {Function} callback The callback to call after, takes event object as one argument\n   *  @param {Object} [data = {}] Optional data to pass along\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\n   */\n  fetch(event, callback, data = {}, runOnce = false) {\n    if (!this.connecting && !this.connected) {\n      throw 'No connection, please call connect() first';\n    }\n\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n\n      callback(e);\n    };\n\n    this.on(event, internalCallback);\n    this.send(event, data);\n  }\n\n  /**\n   *  A convience method for listening to an event and then responding with some data\n   *  right away. Automatically removes the listener\n   *  @method respond\n   *  @param {String} event The name of the event\n   *  @param {Object | function} [data = {}] The object to pass back.\n   *  \tMay also be a function; the return value will be sent as data in this case.\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\n   */\n  respond(event, data = {}, runOnce = false) {\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n      this.send(event, 'function' === typeof data ? data() : data);\n    };\n    this.on(event, internalCallback);\n  }\n\n  /**\n   *  Destroy and don't user after this\n   *  @method destroy\n   */\n  destroy() {\n    super.destroy();\n    this.disconnect();\n    this._sendLater.length = 0;\n  }\n\n  /**\n   *\n   * Returns the correct parent element for Bellhop's context\n   * @readonly\n   * @memberof Bellhop\n   */\n  get target() {\n    return this.isChild ? window.parent : this.iframe.contentWindow;\n  }\n}\n","//------------------------------------------------------------------------------\r\n\r\nexport const u = {}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\n// Return true if we are in an iframe\r\n// https://stackoverflow.com/a/326076/3567351\r\nu.inIFrame = () => {\r\n  try {\r\n    return window.self !== window.top\r\n  } catch (e) {\r\n    return true\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nu.dom = {\r\n  // Resolve when DOM is ready\r\n  onDOMReady() {\r\n    return new Promise(resolve => {\r\n      if (document.readyState !== 'loading') {\r\n        resolve()\r\n      } else {\r\n        document.addEventListener('DOMContentLoaded', resolve)\r\n      }\r\n    })\r\n  },\r\n\r\n  // https://github.com/imagitama/nodelist-foreach-polyfill/blob/master/index.js\r\n  forEach(nodeList, callback, scope) {\r\n    // Duplicate the list, so that we can iterate over a dynamic node list\r\n    // returned by getElementsByClassName() and the likes. If we don't, the\r\n    // following won't work, as we change the list dynamically while we iterate\r\n    // over it:\r\n    // u.dom.forEach(document.getElementsByClassName('toto'), node => node.classList.remove('toto'))\r\n    const list = [...nodeList]\r\n    for (let i = 0; i < list.length; i++) {\r\n      callback.call(scope || window, list[i], i)\r\n    }\r\n  },\r\n\r\n  wrap(el, wrapper) {\r\n    el.parentNode.insertBefore(wrapper, el)\r\n    wrapper.appendChild(el)\r\n    return wrapper\r\n  },\r\n\r\n  wrapAll(elArray, wrapper) {\r\n    if (elArray && elArray.length) {\r\n      // Duplicate the array in case it is a DOM nodeList than would be modified\r\n      // while we move elements\r\n      const copyArray = Array.prototype.slice.call(elArray)\r\n      copyArray[0].parentNode.insertBefore(wrapper, copyArray[0])\r\n      copyArray.forEach(el => wrapper.appendChild(el))\r\n    }\r\n    return wrapper\r\n  },\r\n\r\n  createElement(htmlString) {\r\n    const div = document.createElement('div')\r\n    div.innerHTML = htmlString.trim()\r\n    return div.firstChild\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n","import * as comTypes from './com-types'\r\nimport { Bellhop } from 'bellhop-iframe'\r\nimport { u } from './utils'\r\n\r\nexport const inIFrame = u.inIFrame\r\n\r\nclass ComToPlugin {\r\n  //----------------------------------------------------------------------------\r\n\r\n  constructor() {\r\n    this._bellhop = new Bellhop()\r\n    this._timer = null\r\n    this._onConnected = null\r\n\r\n    // This is called avery time the iframe reloads\r\n    this._bellhop.on('connected', () => {\r\n      if (this._timer) {\r\n        clearTimeout(this._timer)\r\n        this._timer = null\r\n      }\r\n      this._onConnected && this._onConnected()\r\n    })\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @param {Object} arg\r\n   * @param {string} arg.discourseOrigin\r\n   * @param {OnConnectedCallback} arg.onConnected\r\n   * @param {number} arg.timeout\r\n   * @param {OnTimeoutCallback} arg.onTimeout\r\n   */\r\n\r\n  connect({ discourseOrigin, onConnected, timeout, onTimeout }) {\r\n    if (!u.inIFrame()) {\r\n      throw new Error('comToPlugin must be used in an iframe')\r\n    }\r\n    this.disconnect()\r\n    this._onConnected = onConnected\r\n    this._timer = timeout\r\n      ? setTimeout(() => {\r\n          onTimeout && onTimeout()\r\n        }, timeout)\r\n      : null\r\n    this._bellhop.connect(undefined, discourseOrigin)\r\n  }\r\n\r\n  disconnect() {\r\n    if (this._timer) {\r\n      clearTimeout(this._timer)\r\n      this._timer = null\r\n    }\r\n    this._bellhop.disconnect()\r\n  }\r\n\r\n  isConnected() {\r\n    return this._bellhop.connected\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @callback OnDiscourseRoutePushedCallback\r\n   * @param {RouteAndDescrAndCountsAndContext}\r\n   */\r\n  /**\r\n   *  @param {OnDiscourseRoutePushedCallback} cb\r\n   */\r\n  onDiscourseRoutePushed(cb) {\r\n    this._bellhop.on('m2', e => cb(e.data))\r\n  }\r\n\r\n  /**\r\n   * @callback OnCountsChangedCallback\r\n   * @param {Counts}\r\n   */\r\n  /**\r\n   *  @param {OnCountsChangedCallback} cb\r\n   */\r\n  onCountsChanged(cb) {\r\n    this._bellhop.on('m3', e => cb(e.data))\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @param {RouteAndModeAndContext}\r\n   */\r\n  postSetDiscourseRoute({ route, mode, clientContext }) {\r\n    this._bellhop.send('m4', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {HashAndMode}\r\n   */\r\n  postSetHash({ hash, mode }) {\r\n    this._bellhop.send('m5', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {RouteProps} props\r\n   */\r\n  postSetRouteProps({ category, discourseTitle, error }) {\r\n    this._bellhop.send('m6', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {[Redirect]} redirects\r\n   */\r\n  postSetRedirects(redirects) {\r\n    this._bellhop.send('m7', redirects)\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n}\r\n\r\nexport const comToPlugin = new ComToPlugin()\r\n"],"names":["BellhopEventDispatcher","_listeners","name","callback","priority","this","_priority","parseInt","indexOf","push","length","sort","listenerSorter","a","b","index","splice","event","data","type","i","Bellhop","id","Math","random","connected","isChild","connecting","origin","_sendLater","iframe","receive","_this","bind","message","target","source","onConnectionReceived","JSON","parse","err","error","trigger","postMessage","send","disconnect","HTMLIFrameElement","supported","window","addEventListener","removeEventListener","stringify","runOnce","on","internalCallback","off","e","parent","contentWindow","u","inIFrame","self","top","dom","onDOMReady","Promise","resolve","document","readyState","[object Object]","nodeList","scope","list","call","wrap","el","wrapper","parentNode","insertBefore","appendChild","elArray","copyArray","Array","prototype","slice","forEach","htmlString","div","createElement","innerHTML","trim","firstChild","comToPlugin","_bellhop","_timer","_onConnected","clearTimeout","discourseOrigin","onConnected","timeout","onTimeout","Error","setTimeout","connect","undefined","cb","route","mode","clientContext","arguments","hash","category","discourseTitle","redirects"],"mappings":"kvBAUaA,yCAOJC,mDAUJC,EAAMC,OAAUC,yDAAW,EACvBC,KAAKJ,WAAWC,UACdD,WAAWC,SAETI,UAAYC,SAASH,IAAa,GAGtC,IAAMC,KAAKJ,WAAWC,GAAMM,QAAQL,UAIpCF,WAAWC,GAAMO,KAAKN,GAEvBE,KAAKJ,WAAWC,GAAMQ,OAAS,QAC5BT,WAAWC,GAAMS,KAAKN,KAAKO,wDAWrBC,EAAGC,UACTD,EAAEP,UAAYQ,EAAER,sCAUrBJ,EAAMC,eACJE,KAAKJ,WAAWC,eAIhBC,OAKEY,EAAQV,KAAKJ,WAAWC,GAAMM,QAAQL,IAE3C,EAAIY,GAAQV,KAAKJ,WAAWC,GAAMc,OAAOD,EAAO,eANxCV,KAAKJ,WAAWC,mCAenBe,OAAOC,+DACO,iBAATD,YAEDA,OACA,qBAAoBC,gBAAAA,KAAQ,OAASA,EAAOA,gBAI3Bb,KAAKJ,WAAWgB,EAAME,UAC1C,IAAIC,EAAIf,KAAKJ,WAAWgB,EAAME,MAAMT,OAAS,EAAGU,GAAK,EAAGA,SACtDnB,WAAWgB,EAAME,MAAMC,GAAGH,0CAU9BhB,uBChGIoB,+BAMCC,yDAAsB,IAAhBC,KAAKC,SAAkB,sFAOlCF,cAAgBA,IAQhBG,eAQAC,aAQAC,gBAQAC,OAAS,MAOTC,gBAQAC,OAAS,OAOTC,QAAUC,EAAKD,QAAQE,6UAnEHjC,sCAsFnBkC,MAGF7B,KAAK8B,SAAWD,EAAQE,UAKP,cAAjBF,EAAQhB,UAgBPmB,qBAAqBH,EAAQhB,eAf5BA,EAAOgB,EAAQhB,QAEf,iBAAoBA,QAEboB,KAAKC,MAAMrB,GAClB,MAAOsB,WACCC,MAAM,kBAAmBD,GAGjCnC,KAAKoB,WAAa,qBAAoBP,gBAAAA,KAAQA,EAAKC,WAChDuB,QAAQxB,iDAYEgB,QACdP,mBACAF,aAGApB,KAAKqB,cACHS,OAAOQ,YAAYT,EAAS7B,KAAKuB,YAKnC,IAAIR,EAAI,EAAGA,EAAIf,KAAKwB,WAAWnB,OAAQU,IAAK,OACxBf,KAAKwB,WAAWT,GAA/BD,IAAAA,KAAMD,IAAAA,UACT0B,KAAKzB,EAAMD,QAEbW,WAAWnB,OAAS,OAGpBgC,QAAQ,6CAWPZ,OAAQF,yDAAS,IAEnBvB,KAAKsB,kBAKJkB,kBAGAlB,cAGDG,aAAkBgB,yBACfhB,OAASA,QAIXJ,iBAAUI,OAEViB,aACD1C,KAAKqB,eAEFqB,UAAYC,QAAUlB,QAGxBF,OAASA,SAEPqB,iBAAiB,UAAW5C,KAAK0B,SAEpC1B,KAAKqB,UAEHsB,SAAW3C,KAAK8B,YACbO,QAAQ,eAIRP,OAAOQ,YAAY,YAAatC,KAAKuB,oDAUzCH,kBACAE,mBACAC,OAAS,UACTE,OAAS,UACTJ,gBACAG,WAAWnB,OAAS,SAElBwC,oBAAoB,UAAW7C,KAAK0B,sCASxCZ,OAAMD,+DACW,iBAATC,OACH,sCAGFe,kBAKF7B,KAAKsB,gBACFE,WAAWpB,KAAKyB,QAEhBC,OAAOQ,YAAYL,KAAKa,UAAUjB,GAAU7B,KAAKuB,sCAcpDX,EAAOd,cAAUe,4DAAWkC,8DAC3B/C,KAAKsB,aAAetB,KAAKoB,eACtB,kDAWH4B,GAAGpC,EARiB,SAAnBqC,KACAF,KACGG,IAAIC,EAAErC,KAAMmC,KAGVE,UAINZ,KAAK3B,EAAOC,mCAYXD,cAAOC,4DAAWkC,+DAOnBC,GAAGpC,EANiB,SAAnBqC,KACAF,KACGG,IAAIC,EAAErC,KAAMmC,KAEdV,KAAK3B,EAAO,mBAAsBC,EAAOA,IAASA,6XAWpD2B,kBACAhB,WAAWnB,OAAS,wCAUlBL,KAAKqB,QAAUsB,OAAOS,OAASpD,KAAKyB,OAAO4B,uBCvS/C,MAAMC,EAAI,CAMjBC,SAAa,KACX,IACE,OAAOZ,OAAOa,OAASb,OAAOc,IAC9B,MAAON,GACP,OAAO,KAMXG,EAAEI,IAAM,CAENC,WAAU,IACD,IAAIC,QAAQC,IACW,YAAxBC,SAASC,WACXF,IAEAC,SAASlB,iBAAiB,mBAAoBiB,KAMpDG,QAAQC,EAAUnE,EAAUoE,GAM1B,MAAMC,EAAO,IAAIF,GACjB,IAAK,IAAIlD,EAAI,EAAGA,EAAIoD,EAAK9D,OAAQU,IAC/BjB,EAASsE,KAAKF,GAASvB,OAAQwB,EAAKpD,GAAIA,IAI5CsD,KAAI,CAACC,EAAIC,KACPD,EAAGE,WAAWC,aAAaF,EAASD,GACpCC,EAAQG,YAAYJ,GACbC,GAGTP,QAAQW,EAASJ,GACf,GAAII,GAAWA,EAAQtE,OAAQ,CAG7B,MAAMuE,EAAYC,MAAMC,UAAUC,MAAMX,KAAKO,GAC7CC,EAAU,GAAGJ,WAAWC,aAAaF,EAASK,EAAU,IACxDA,EAAUI,QAAQV,GAAMC,EAAQG,YAAYJ,IAE9C,OAAOC,GAGTP,cAAciB,GACZ,MAAMC,EAAMpB,SAASqB,cAAc,OAEnC,OADAD,EAAIE,UAAYH,EAAWI,OACpBH,EAAII,mBC3DF/B,EAAWD,EAAEC,SAiHbgC,EAAc,IA/G3B,MAGEvB,cACEhE,KAAKwF,SAAW,IAAIxE,EACpBhB,KAAKyF,OAAS,KACdzF,KAAK0F,aAAe,KAGpB1F,KAAKwF,SAASxC,GAAG,YAAa,KACxBhD,KAAKyF,SACPE,aAAa3F,KAAKyF,QAClBzF,KAAKyF,OAAS,MAEhBzF,KAAK0F,cAAgB1F,KAAK0F,iBAc9B1B,SAAQ4B,gBAAEA,EAAeC,YAAEA,EAAWC,QAAEA,EAAOC,UAAEA,IAC/C,IAAKzC,EAAEC,WACL,MAAM,IAAIyC,MAAM,yCAElBhG,KAAKwC,aACLxC,KAAK0F,aAAeG,EACpB7F,KAAKyF,OAASK,EACVG,WAAW,KACTF,GAAaA,KACZD,GACH,KACJ9F,KAAKwF,SAASU,aAAQC,EAAWP,GAGnC5B,aACMhE,KAAKyF,SACPE,aAAa3F,KAAKyF,QAClBzF,KAAKyF,OAAS,MAEhBzF,KAAKwF,SAAShD,aAGhBwB,cACE,OAAOhE,KAAKwF,SAASpE,UAYvB4C,uBAAuBoC,GACrBpG,KAAKwF,SAASxC,GAAG,KAAMG,GAAKiD,EAAGjD,EAAEtC,OAUnCmD,gBAAgBoC,GACdpG,KAAKwF,SAASxC,GAAG,KAAMG,GAAKiD,EAAGjD,EAAEtC,OAQnCmD,uBAAsBqC,MAAEA,EAAKC,KAAEA,EAAIC,cAAEA,IACnCvG,KAAKwF,SAASjD,KAAK,KAAMiE,UAAU,IAMrCxC,aAAYyC,KAAEA,EAAIH,KAAEA,IAClBtG,KAAKwF,SAASjD,KAAK,KAAMiE,UAAU,IAMrCxC,mBAAkB0C,SAAEA,EAAQC,eAAEA,EAAcvE,MAAEA,IAC5CpC,KAAKwF,SAASjD,KAAK,KAAMiE,UAAU,IAMrCxC,iBAAiB4C,GACf5G,KAAKwF,SAASjD,KAAK,KAAMqE"}