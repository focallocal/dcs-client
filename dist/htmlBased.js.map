{"version":3,"file":"htmlBased.js","sources":["../src/utils.js","../node_modules/bellhop-iframe/src/BellhopEventDispatcher.js","../node_modules/bellhop-iframe/src/Bellhop.js","../src/comToPlugin.js","../src/htmlBased.js"],"sourcesContent":["//------------------------------------------------------------------------------\r\n\r\nexport const u = {}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\n// Return true if we are in an iframe\r\n// https://stackoverflow.com/a/326076/3567351\r\nu.inIFrame = () => {\r\n  try {\r\n    return window.self !== window.top\r\n  } catch (e) {\r\n    return true\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nu.dom = {\r\n  // Resolve when DOM is ready\r\n  onDOMReady() {\r\n    return new Promise(resolve => {\r\n      if (document.readyState !== 'loading') {\r\n        resolve()\r\n      } else {\r\n        document.addEventListener('DOMContentLoaded', resolve)\r\n      }\r\n    })\r\n  },\r\n\r\n  // https://github.com/imagitama/nodelist-foreach-polyfill/blob/master/index.js\r\n  forEach(nodeList, callback, scope) {\r\n    // Duplicate the list, so that we can iterate over a dynamic node list\r\n    // returned by getElementsByClassName() and the likes. If we don't, the\r\n    // following won't work, as we change the list dynamically while we iterate\r\n    // over it:\r\n    // u.dom.forEach(document.getElementsByClassName('toto'), node => node.classList.remove('toto'))\r\n    const list = [...nodeList]\r\n    for (let i = 0; i < list.length; i++) {\r\n      callback.call(scope || window, list[i], i)\r\n    }\r\n  },\r\n\r\n  wrap(el, wrapper) {\r\n    el.parentNode.insertBefore(wrapper, el)\r\n    wrapper.appendChild(el)\r\n    return wrapper\r\n  },\r\n\r\n  wrapAll(elArray, wrapper) {\r\n    if (elArray && elArray.length) {\r\n      // Duplicate the array in case it is a DOM nodeList than would be modified\r\n      // while we move elements\r\n      const copyArray = Array.prototype.slice.call(elArray)\r\n      copyArray[0].parentNode.insertBefore(wrapper, copyArray[0])\r\n      copyArray.forEach(el => wrapper.appendChild(el))\r\n    }\r\n    return wrapper\r\n  },\r\n\r\n  createElement(htmlString) {\r\n    const div = document.createElement('div')\r\n    div.innerHTML = htmlString.trim()\r\n    return div.firstChild\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n","/**\n * Function with a added priority type\n * @typedef {Function} PriorityFunction\n * @property {number} _priority\n */\n\n/**\n * Generic event dispatcher\n * @class  BellhopEventDispatcher\n */\nexport class BellhopEventDispatcher {\n  /**\n   *  The collection of event listeners\n   *  @property {Object} _listeners\n   *  @private\n   */\n  constructor() {\n    this._listeners = {};\n  }\n\n  /**\n   *  Add an event listener to the listen to an event from either the parent or iframe\n   *  @method on\n   *  @param {String} name The name of the event to listen\n   *  @param {PriorityFunction} callback The handler when an event is triggered\n   *  @param {number} [priority=0] The priority of the event listener. Higher numbers are handled first.\n   */\n  on(name, callback, priority = 0) {\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    callback._priority = parseInt(priority) || 0;\n\n    // If callback is already set to this event\n    if (-1 !== this._listeners[name].indexOf(callback)) {\n      return;\n    }\n\n    this._listeners[name].push(callback);\n\n    if (this._listeners[name].length > 1) {\n      this._listeners[name].sort(this.listenerSorter);\n    }\n  }\n\n  /**\n   * @private\n   * @param {PriorityFunction} a\n   * @param {PriorityFunction} b\n   * @returns {number};\n   *  Sorts listeners added by .on() by priority\n   */\n  listenerSorter(a, b) {\n    return a._priority - b._priority;\n  }\n\n  /**\n   *  Remove an event listener\n   *  @method off\n   *  @param {String} name The name of event to listen for. If undefined, remove all listeners.\n   *  @param {Function} [callback] The optional handler when an event is triggered, if no callback\n   *         is set then all listeners by type are removed\n   */\n  off(name, callback) {\n    if (this._listeners[name] === undefined) {\n      return;\n    }\n\n    if (callback === undefined) {\n      delete this._listeners[name];\n      return;\n    }\n\n    const index = this._listeners[name].indexOf(callback);\n\n    -1 < index ? this._listeners[name].splice(index, 1) : undefined;\n  }\n\n  /**\n   *  Trigger any event handlers for an event type\n   *  @method trigger\n   *  @param {object | String} event The event to send\n   *  @param {object} [data = {}] optional data to send to other areas in the app that are listening for this event\n   */\n  trigger(event, data = {}) {\n    if (typeof event == 'string') {\n      event = {\n        type: event,\n        data: 'object' === typeof data && null !== data ? data : {}\n      };\n    }\n\n    if ('undefined' !== typeof this._listeners[event.type]) {\n      for (let i = this._listeners[event.type].length - 1; i >= 0; i--) {\n        this._listeners[event.type][i](event);\n      }\n    }\n  }\n\n  /**\n   * Reset the listeners object\n   * @method  destroy\n   */\n  destroy() {\n    this._listeners = {};\n  }\n}\n","import { BellhopEventDispatcher } from './BellhopEventDispatcher.js';\n\n/**\n *  Abstract the communication layer between the iframe\n *  and the parent DOM\n *  @class Bellhop\n *  @extends BellhopEventDispatcher\n */\nexport class Bellhop extends BellhopEventDispatcher {\n  /**\n   * Creates an instance of Bellhop.\n   * @memberof Bellhop\n   * @param { string | number } id the id of the Bellhop instance\n   */\n  constructor(id = (Math.random() * 100) | 0) {\n    super();\n\n    /**\n     *  The instance ID for bellhop\n     *  @property {string} id\n     */\n    this.id = `BELLHOP:${id}`;\n    /**\n     *  If we are connected to another instance of the bellhop\n     *  @property {Boolean} connected\n     *  @readOnly\n     *  @default false\n     *  @private\n     */\n    this.connected = false;\n\n    /**\n     *  If this instance represents an iframe instance\n     *  @property {Boolean} isChild\n     *  @private\n     *  @default true\n     */\n    this.isChild = true;\n\n    /**\n     *  If we are current trying to connec\n     *  @property {Boolean} connecting\n     *  @default false\n     *  @private\n     */\n    this.connecting = false;\n\n    /**\n     *  If using cross-domain, the domain to post to\n     *  @property {string} origin\n     *  @private\n     *  @default \"*\"\n     */\n    this.origin = '*';\n\n    /**\n     *  Save any sends to wait until after we're done\n     *  @property {Array} _sendLater\n     *  @private\n     */\n    this._sendLater = [];\n\n    /**\n     * The iframe element\n     * @property {HTMLIFrameElement} iframe\n     * @private\n     * @readOnly\n     */\n    this.iframe = null;\n\n    /**\n     * The bound receive function\n     * @property {Function} receive\n     * @private\n     */\n    this.receive = this.receive.bind(this);\n  }\n\n  /**\n   *  The connection has been established successfully\n   *  @event connected\n   */\n\n  /**\n   *  Connection could not be established\n   *  @event failed\n   */\n\n  /**\n   *  Handle messages in the window\n   *  @method receive\n   *  @param { MessageEvent } message the post message received from another bellhop instance\n   *  @private\n   */\n  receive(message) {\n    // Ignore messages that don't originate from the target\n    // we're connected to\n    if (this.target !== message.source) {\n      return;\n    }\n\n    // If this is not the initial connection message\n    if (message.data !== 'connected') {\n      let data = message.data;\n      // Check to see if the data was sent as a stringified json\n      if ('string' === typeof data) {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          console.error('Bellhop error: ', err);\n        }\n      }\n      if (this.connected && 'object' === typeof data && data.type) {\n        this.trigger(data);\n      }\n      return;\n    }\n    // Else setup the connection\n    this.onConnectionReceived(message.data);\n  }\n  /**\n   * @memberof Bellhop\n   * @param {object} message the message received from the other bellhop instance\n   * @private\n   */\n  onConnectionReceived(message) {\n    this.connecting = false;\n    this.connected = true;\n\n    // Be polite and respond to the child that we're ready\n    if (!this.isChild) {\n      this.target.postMessage(message, this.origin);\n    }\n\n    // If we have any sends waiting to send\n    // we are now connected and it should be okay\n    for (let i = 0; i < this._sendLater.length; i++) {\n      const { type, data } = this._sendLater[i];\n      this.send(type, data);\n    }\n    this._sendLater.length = 0;\n\n    // If there is a connection event assigned call it\n    this.trigger('connected');\n  }\n\n  /**\n   *  Setup the connection\n   *  @method connect\n   *  @param {HTMLIFrameElement} iframe The iframe to communicate with. If no value is set, the assumption\n   *         is that we're the child trying to communcate with our window.parent\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\n   *  @return {Bellhop} Return instance of current object\n   */\n  connect(iframe, origin = '*') {\n    // Ignore if we're already trying to connect\n    if (this.connecting) {\n      return;\n    }\n\n    // Disconnect from any existing connection\n    this.disconnect();\n\n    // We are trying to connect\n    this.connecting = true;\n\n    // The iframe if we're the parent\n    if (iframe instanceof HTMLIFrameElement) {\n      this.iframe = iframe;\n    }\n\n    // The instance of bellhop is inside the iframe\n    this.isChild = iframe === undefined;\n\n    this.supported = true;\n    if (this.isChild) {\n      // for child pages, the window passed must be a different window\n      this.supported = window != iframe;\n    }\n\n    this.origin = origin;\n\n    window.addEventListener('message', this.receive);\n\n    if (this.isChild) {\n      // No parent, can't connect\n      if (window === this.target) {\n        this.trigger('failed');\n      } else {\n        // If connect is called after the window is ready\n        // we can go ahead and send the connect message\n        this.target.postMessage('connected', this.origin);\n      }\n    }\n  }\n\n  /**\n   *  Disconnect if there are any open connections\n   *  @method disconnect\n   */\n  disconnect() {\n    this.connected = false;\n    this.connecting = false;\n    this.origin = null;\n    this.iframe = null;\n    this.isChild = true;\n    this._sendLater.length = 0;\n\n    window.removeEventListener('message', this.receive);\n  }\n\n  /**\n   *  Send an event to the connected instance\n   *  @method send\n   *  @param {string} type name/type of the event\n   *  @param {*} [data = {}] Additional data to send along with event\n   */\n  send(type, data = {}) {\n    if (typeof type !== 'string') {\n      throw 'The event type must be a string';\n    }\n\n    const message = {\n      type,\n      data\n    };\n\n    if (this.connecting) {\n      this._sendLater.push(message);\n    } else {\n      this.target.postMessage(JSON.stringify(message), this.origin);\n    }\n  }\n\n  /**\n   *  A convenience method for sending and the listening to create\n   *  a singular link to fetching data. This is the same calling send\n   *  and then getting a response right away with the same event.\n   *  @method fetch\n   *  @param {String} event The name of the event\n   *  @param {Function} callback The callback to call after, takes event object as one argument\n   *  @param {Object} [data = {}] Optional data to pass along\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\n   */\n  fetch(event, callback, data = {}, runOnce = false) {\n    if (!this.connecting && !this.connected) {\n      throw 'No connection, please call connect() first';\n    }\n\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n\n      callback(e);\n    };\n\n    this.on(event, internalCallback);\n    this.send(event, data);\n  }\n\n  /**\n   *  A convience method for listening to an event and then responding with some data\n   *  right away. Automatically removes the listener\n   *  @method respond\n   *  @param {String} event The name of the event\n   *  @param {Object | function} [data = {}] The object to pass back.\n   *  \tMay also be a function; the return value will be sent as data in this case.\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\n   */\n  respond(event, data = {}, runOnce = false) {\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n      this.send(event, 'function' === typeof data ? data() : data);\n    };\n    this.on(event, internalCallback);\n  }\n\n  /**\n   *  Destroy and don't user after this\n   *  @method destroy\n   */\n  destroy() {\n    super.destroy();\n    this.disconnect();\n    this._sendLater.length = 0;\n  }\n\n  /**\n   *\n   * Returns the correct parent element for Bellhop's context\n   * @readonly\n   * @memberof Bellhop\n   */\n  get target() {\n    return this.isChild ? window.parent : this.iframe.contentWindow;\n  }\n}\n","import * as comTypes from './com-types'\r\nimport { Bellhop } from 'bellhop-iframe'\r\nimport { u } from './utils'\r\n\r\nexport const inIFrame = u.inIFrame\r\n\r\nclass ComToPlugin {\r\n  //----------------------------------------------------------------------------\r\n\r\n  constructor() {\r\n    this._bellhop = new Bellhop()\r\n    this._timer = null\r\n    this._onConnected = null\r\n\r\n    // This is called avery time the iframe reloads\r\n    this._bellhop.on('connected', () => {\r\n      if (this._timer) {\r\n        clearTimeout(this._timer)\r\n        this._timer = null\r\n      }\r\n      this._onConnected && this._onConnected()\r\n    })\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @param {Object} arg\r\n   * @param {string} arg.discourseOrigin\r\n   * @param {OnConnectedCallback} arg.onConnected\r\n   * @param {number} arg.timeout\r\n   * @param {OnTimeoutCallback} arg.onTimeout\r\n   */\r\n  connect({ discourseOrigin, onConnected, timeout, onTimeout }) {\r\n    if (!u.inIFrame()) {\r\n      throw new Error('comToPlugin must be used in an iframe')\r\n    }\r\n    this.disconnect()\r\n    this._onConnected = onConnected\r\n    this._timer = timeout\r\n      ? setTimeout(() => {\r\n          onTimeout && onTimeout()\r\n        }, timeout)\r\n      : null\r\n    this._bellhop.connect(undefined, discourseOrigin)\r\n  }\r\n\r\n  disconnect() {\r\n    if (this._timer) {\r\n      clearTimeout(this._timer)\r\n      this._timer = null\r\n    }\r\n    this._bellhop.disconnect()\r\n  }\r\n\r\n  isConnected() {\r\n    return this._bellhop.connected\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @callback OnDiscourseRoutePushedCallback\r\n   * @param {RoutePushedParams}\r\n   */\r\n  /**\r\n   *  @param {OnDiscourseRoutePushedCallback} cb\r\n   */\r\n  onDiscourseRoutePushed(cb) {\r\n    this._bellhop.on('m2', e => cb(e.data))\r\n  }\r\n\r\n  /**\r\n   * @callback OnCountsChangedCallback\r\n   * @param {Counts}\r\n   */\r\n  /**\r\n   *  @param {OnCountsChangedCallback} cb\r\n   */\r\n  onCountsChanged(cb) {\r\n    this._bellhop.on('m3', e => cb(e.data))\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @param {SetRouteParams}\r\n   */\r\n  postSetDiscourseRoute({ route, mode, clientContext }) {\r\n    this._bellhop.send('m4', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {RouteProps} props\r\n   */\r\n  postSetRouteProps({ category, discourseTitle, error }) {\r\n    this._bellhop.send('m6', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {[Redirect]} redirects\r\n   */\r\n  postSetRedirects(redirects) {\r\n    this._bellhop.send('m7', redirects)\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n}\r\n\r\nexport const comToPlugin = new ComToPlugin()\r\n\r\n//==============================================================================\r\n// Better scrolling in iframe\r\n//==============================================================================\r\n\r\n/*\r\nIn an iframe, when user scrolls past the top/bottom of the page with the mouse \r\nwheel, the parent window scrolls instead. This isn't good in Discourse, where\r\nthe iframe is full height on the right.\r\nSo what we need to do os to intercept the wheel event and cancel it before it \r\nis forwarded to the parent window.\r\nNotice that the \"scroll\" event fires *after* scrolling has been done, so it is \r\nuseless in our case\r\n*/\r\n\r\nconst scrollLimitY =\r\n  Math.max(\r\n    document.body.scrollHeight,\r\n    document.body.offsetHeight,\r\n    document.documentElement.clientHeight,\r\n    document.documentElement.scrollHeight,\r\n    document.documentElement.offsetHeight\r\n  ) - window.innerHeight\r\n\r\nfunction handleScrollEvent(e, scrollDirection) {\r\n  if (scrollDirection === 'UP') {\r\n    if (window.scrollY === 0) {\r\n      e.preventDefault()\r\n    }\r\n  } else if (scrollDirection === 'DOWN') {\r\n    if (window.scrollY === scrollLimitY) {\r\n      e.preventDefault()\r\n    }\r\n  }\r\n}\r\n\r\nwindow.addEventListener(\r\n  'wheel',\r\n  e => {\r\n    if (e.deltaY < 0) {\r\n      handleScrollEvent(e, 'UP')\r\n    } else if (e.deltaY > 0) {\r\n      handleScrollEvent(e, 'DOWN')\r\n    }\r\n  },\r\n  { passive: false } // Passive is true by default on all scroll-related events under Chrome and Firefox\r\n)\r\n\r\ndocument.addEventListener('keydown', e => {\r\n  if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {\r\n    return\r\n  }  \r\n  if (e.code === 'ArrowUp' || e.code === 'PageUp') {\r\n    handleScrollEvent(e, 'UP')    \r\n  }\r\n  if (e.code === 'ArrowDown' || e.code === 'PageDown') {\r\n    handleScrollEvent(e, 'DOWN')\r\n  }\r\n})\r\n\r\n//==============================================================================","import { u } from './utils'\r\nimport { comToPlugin } from './comToPlugin'\r\n\r\n//==============================================================================\r\n//==============================================================================\r\n//==============================================================================\r\n\r\nexport { u, comToPlugin }\r\n\r\n//==============================================================================\r\n//==============================================================================\r\n//==============================================================================\r\n\r\nconst TRIGGER_CLICK_TARGETS =\r\n  '.dcs-icons, .dcs-trigger.dcs-no-balloon .dcs-trigger-span, .dcs-trigger.dcs-no-balloon.dcs-no-span'\r\n\r\n//==============================================================================\r\n//==============================================================================\r\n//==============================================================================\r\n\r\nclass HtmlBasedSingleton {\r\n  //----------------------------------------------------------------------------\r\n\r\n  constructor() {\r\n    this.selTriggerNode = null\r\n    this.resizeTimer = null\r\n    this.currentRoute = null\r\n    comToPlugin.onDiscourseRoutePushed(this._onDiscourseRoutePushed.bind(this))\r\n    comToPlugin.onCountsChanged(({ counts }) => console.log('counts: ', counts))\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  connect({ discourseOrigin, timeout }) {\r\n    return new Promise((resolve, reject) => {\r\n      // Establish communication with the Discourse plugin\r\n      this.resolveConnect = resolve\r\n      comToPlugin.connect({\r\n        discourseOrigin,\r\n        timeout,\r\n        onTimeout: () => reject('timeout')\r\n      })\r\n    })\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  parseDom({ descr, pageName, discourseOrigin, counts }) {\r\n    // We will resolve all links to absolute without proxy (\"https://website.com/bar/index.html\")\r\n    // We start by retrieving the url of the current page url without the proxy\r\n    const page = descr.pages.find(p => p.name === pageName)\r\n\r\n    // Attempt to support more dynamic websites: manage links and trigger that\r\n    // are added later through javascript\r\n    new MutationObserver(mutationsList => {\r\n      for (let mutation of mutationsList) {\r\n        for (let addedNode of mutation.addedNodes) {\r\n          // We are interested about nodes only (not text, etc.)\r\n          if (addedNode.nodeType !== Node.ELEMENT_NODE) {\r\n            return\r\n          }\r\n\r\n          // Go through added links\r\n          const links = [\r\n            ...(addedNode.tagName === 'A' ? [addedNode] : []),\r\n            ...addedNode.getElementsByTagName('A')\r\n          ]\r\n          for (let a of links) {\r\n            console.log(\r\n              'Docuss experimental feature: a link has been dynamically added',\r\n              a\r\n            )\r\n            this._transformLink({ a, descr, discourseOrigin, page })\r\n          }\r\n\r\n          // Go through added click targets\r\n          const targets = [\r\n            ...(addedNode.matches(TRIGGER_CLICK_TARGETS) ? [addedNode] : []),\r\n            ...addedNode.querySelectorAll(TRIGGER_CLICK_TARGETS)\r\n          ]\r\n          for (let t of targets) {\r\n            // Case a trigger target has been dynamically added\r\n            console.log(\r\n              'Docuss experimental feature: a trigger target has been dynamically added',\r\n              t\r\n            )\r\n            this._addTriggerClickEvent({ node: t, pageName })\r\n          }\r\n\r\n          // Check if triggers have been added\r\n          const triggers = [\r\n            ...(addedNode.classList.contains('dcs-trigger') ? [addedNode] : []),\r\n            ...addedNode.getElementsByClassName('dcs-trigger')\r\n          ]\r\n          if (triggers.length) {\r\n            // Case one or several trigger nodes have been dynamically added\r\n            console.log(\r\n              'Docuss experimental feature: one or several triggers have been dynamically added',\r\n              triggers\r\n            )\r\n            _setAdditionalRedirects()\r\n          }\r\n        }\r\n      }\r\n    }).observe(document.documentElement, { childList: true, subtree: true })\r\n\r\n    // Case click nowhere special (all Docuss specific events ar handles\r\n    // elsewhere with preventDefault)\r\n    window.addEventListener('click', () => {\r\n      // Don't deselect when user is selecting text\r\n      if (\r\n        !window.getSelection().toString() &&\r\n        this.selTriggerNode &&\r\n        this.selTriggerNode.dataset.dcsHighlightable\r\n      ) {\r\n        this._selectTriggers(null)\r\n        comToPlugin.postSetDiscourseRoute({\r\n          route: { layout: 0, pageName },\r\n          mode: 'PUSH',\r\n          clientContext: true\r\n        })\r\n      }\r\n    })\r\n\r\n    // Resize event with debounce\r\n    // https://developer.mozilla.org/en-US/docs/Web/Events/resize#setTimeout\r\n    window.addEventListener('resize', evt => {\r\n      if (this.resizeTimer !== null) {\r\n        clearTimeout(this.resizeTimer)\r\n      }\r\n      this.resizeTimer = setTimeout(() => {\r\n        this.resizeTimer = null\r\n        if (this.selTriggerNode) {\r\n          _scrollIntoViewIfNeeded(this.selTriggerNode)\r\n        }\r\n      }, 100)\r\n    })\r\n\r\n    return u.dom.onDOMReady().then(() => {\r\n      // Modify the document links so that they open the correct url in the\r\n      // correct place\r\n      u.dom.forEach(document.getElementsByTagName('a'), a => {\r\n        this._transformLink({ a, descr, discourseOrigin, page })\r\n      })\r\n\r\n      // Add click events on triggers\r\n      u.dom.forEach(document.querySelectorAll(TRIGGER_CLICK_TARGETS), node => {\r\n        this._addTriggerClickEvent({ node, pageName })\r\n      })\r\n\r\n      // Set the additional redirects\r\n      _setAdditionalRedirects()\r\n\r\n      this.runReady = true\r\n\r\n      if (this.delayedRoute) {\r\n        this._onDiscourseRoutePushed({ route: this.delayedRoute })\r\n      }\r\n    })\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  _onDiscourseRoutePushed({ route, descr, counts, clientContext, origin }) {\r\n    this.currentRoute = route\r\n\r\n    // Case init\r\n    if (this.resolveConnect) {\r\n      this.resolveConnect({\r\n        descr,\r\n        pageName: route.pageName,\r\n        discourseOrigin: origin,\r\n        counts\r\n      })\r\n      delete this.resolveConnect\r\n      this.runReady = false\r\n      this.delayedRoute = route\r\n      return\r\n    }\r\n\r\n    // Case we're still not ready\r\n    if (!this.runReady) {\r\n      this.delayedRoute = route\r\n      return\r\n    }\r\n\r\n    // clientContext === true means that this route changed has been\r\n    // triggered by us, so there is nothing more we need to do (because the\r\n    // trigger is already selected)\r\n    if (!clientContext) {\r\n      this._selectTriggers(route.triggerId)\r\n    }\r\n\r\n    // Set the route category and title\r\n    if (route.layout === 2 || route.layout === 3) {\r\n      const category =\r\n        (this.selTriggerNode && this.selTriggerNode.dataset.dcsCategory) ||\r\n        document.documentElement.dataset.dcsCategory\r\n      const discourseTitle =\r\n        (this.selTriggerNode &&\r\n          this.selTriggerNode.dataset.dcsDiscourseTitle) ||\r\n        document.documentElement.dataset.dcsDiscourseTitle\r\n      comToPlugin.postSetRouteProps({ category, discourseTitle })\r\n    }\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  _addTriggerClickEvent({ node, pageName }) {\r\n    node.addEventListener('click', e => {\r\n      // Don't do anything if user is selecting text\r\n      if (window.getSelection().toString()) {\r\n        return\r\n      }\r\n\r\n      const triggerNode = e.target.closest('.dcs-trigger')\r\n      const triggerId = triggerNode.dataset.dcsTriggerId\r\n\r\n      this._selectTriggers(triggerId)\r\n\r\n      comToPlugin.postSetDiscourseRoute({\r\n        route: {\r\n          layout: 3,\r\n          pageName: triggerNode.dataset.dcsPageName || pageName,\r\n          triggerId,\r\n          interactMode: triggerNode.dataset.dcsInteractMode\r\n        },\r\n        mode: 'PUSH',\r\n        clientContext: true\r\n      })\r\n\r\n      // Mandatory because we want our global click event to fire only\r\n      // when user clicks on an empty space\r\n      e.stopPropagation()\r\n    })\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  // Remember there can be more than one trigger per triggerId\r\n  _selectTriggers(triggerId) {\r\n    if (!this.runReady) {\r\n      throw new Error('should be ready')\r\n    }\r\n\r\n    // Unselect everything\r\n    this.selTriggerNode = null\r\n    u.dom.forEach(document.getElementsByClassName('dcs-highlighted'), node =>\r\n      node.classList.remove('dcs-highlighted')\r\n    )\r\n\r\n    // Case there is nothing to select\r\n    if (!triggerId) {\r\n      return\r\n    }\r\n\r\n    // Look for the trigger node in the DOM\r\n    const triggerNodes = document.querySelectorAll(\r\n      `.dcs-trigger[data-dcs-trigger-id=\"${triggerId}\"]`\r\n    )\r\n\r\n    // Case tag not found\r\n    if (!triggerNodes.length) {\r\n      comToPlugin.postSetRouteProps({ error })\r\n      return\r\n    }\r\n\r\n    // Go through selected nodes\r\n    this.selTriggerNode = null\r\n    u.dom.forEach(triggerNodes, node => {\r\n      // Is it a highlightable trigger node?\r\n      if (node.dataset.dcsHighlightable) {\r\n        // Highlight the trigger nodes\r\n        node.classList.add('dcs-highlighted')\r\n\r\n        // Highlight the subsec nodes\r\n        const subsec = node.closest('.dcs-subsec')\r\n        subsec && subsec.classList.add('dcs-highlighted')\r\n\r\n        // Set one node as the selected one, with priority given to the first\r\n        // dcsHighlightable one. THIS IS IMPORTANT: the selected node must be a\r\n        // dcsHighlightable one for the default click handler to work correctly.\r\n        this.selTriggerNode = this.selTriggerNode || node\r\n      }\r\n    })\r\n\r\n    // Case no dcsHighlightable has been found: take the first node\r\n    this.selTriggerNode = this.selTriggerNode || triggerNodes[0]\r\n\r\n    // Bring the selected node into view\r\n    // THIS IS REQUIRED WHEN LAYOUT HAS CHANGED, BUT ALSO WHEN USING THE BACK\r\n    // BUTTON TO A PREVIOUSLY SELECTED HEADING FAR AWAY\r\n    // Need a setTimeout, to ensure the layout change has occurred.\r\n    // 200 is the iframes animation duration + 30 for security\r\n    // +300 because some web sites (ex: VueJS API) have an animation when layout\r\n    // changes from narrow to wide screen.\r\n    setTimeout(() => _scrollIntoViewIfNeeded(this.selTriggerNode), 700)\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  // Something to remember here: a.href and a.getAttribute('href') are two very\r\n  // different things:\r\n  // - a.getAttribute('href') is the absolute or relative url the web designer\r\n  // has written in his html code.\r\n  // - a.href is the resulting absolute url computed by the browser from the\r\n  // a.getAttribute('href') and the current page url.\r\n  _transformLink({ a, descr, discourseOrigin, page }) {\r\n    // Case link is empty\r\n    if (\r\n      !a.href ||\r\n      a.href === '#' ||\r\n      a.href === '#!' || // Yes, some people use this for empty links!\r\n      a.href.startsWith('javascript:')\r\n    ) {\r\n      return\r\n    }\r\n\r\n    // Remove unsupported targets\r\n    if (a.target === '_parent' || a.target === '_top') {\r\n      delete a.target\r\n    }\r\n\r\n    // Transform the \"//discourse\" placeholder by the full link to the\r\n    // Discourse instance\r\n    if (a.hostname === 'discourse') {\r\n      a.href = new URL(a.pathname + a.search + a.hash, discourseOrigin)\r\n    }\r\n\r\n    /*\r\n    There are 3 cases here:\r\n\r\n    Case #1: the link points to another page of our website, such as\r\n    http://my.website.com/otherpage.html. In that case we need to modify the \r\n    link in the DOM to make it point to the Discourse instance, so that \r\n    \"right click + open in a new tab\" will behave correctly. Also, in case of \r\n    single click, we need to cancel the default behavior and ask the Docuss \r\n    plugin to perform the page change within Discourse.\r\n    WE DON'T SUPPORT LINKS USING A DOCUSS PROXY, such as\r\n    http://docuss.proxy.com/http://my.website.com/otherpage.html\r\n\r\n    Case #2: the link is a Discourse link, such as http://my.discourse.com\r\n    or http://my.discourse.com/latest or http://my.discourse.com/docuss/foo.\r\n    There is no need to modify the link in the dom because it is already ok\r\n    for \"right click + open in a new tab\". However, in case of single click,\r\n    we need to cancel the default behavior and ask the Docuss plugin to\r\n    perform the page change within Discourse.\r\n\r\n    Case #3: the link points to an arbitrary external page, such as\r\n    http://google.com. In that case, we just want the link to open in the\r\n    parent window, not the iframe.\r\n    */\r\n\r\n    // Look if the link url is in the website page list (case #1)\r\n    const pageUrlWithoutProxy = page.url\r\n    const possibleRelativeLink = a.getAttribute('href').trim()\r\n    const targetUrlNoProxy = new URL(possibleRelativeLink, pageUrlWithoutProxy)\r\n    targetUrlNoProxy.hash = ''\r\n    const websitePage = descr.pages.find(\r\n      p => p.url.split('#')[0] === targetUrlNoProxy.href\r\n    )\r\n\r\n    // Case #3\r\n    if (!websitePage && a.origin !== discourseOrigin) {\r\n      if (a.target !== '_blank') {\r\n        a.target = '_parent'\r\n      }\r\n      return\r\n    }\r\n\r\n    // Cases #1 and #2\r\n    let route\r\n    if (websitePage) {\r\n      // Case #1\r\n      a.href = discourseOrigin + '/docuss/' + websitePage.name + a.hash\r\n      route = { layout: 0, pageName: websitePage.name, hash: a.hash }\r\n    } else {\r\n      // Case #2 (a.origin === discourseOrigin)\r\n      if (a.pathname.startsWith('/docuss/')) {\r\n        const pageName = a.pathname.substring('/docuss/'.length)\r\n        route = { layout: 0, pageName, hash: a.hash }\r\n      } else if (a.pathname === '/' || a.pathname === '/docuss') {\r\n        // We don't have access to the first website descr, so we cannot\r\n        // compute the target page name. So those 2 lines are very WRONG:\r\n        //    const pageName = descr.pages[0].name\r\n        //    route = { layout: 0, pageName, hash: a.hash }\r\n        // because it would route the user to the first page of the current,\r\n        // descr not the first page of all descr.\r\n        if (a.target !== '_blank') {\r\n          a.target = '_parent'\r\n        }\r\n        return\r\n      } else {\r\n        route = { layout: 1, pathname: a.pathname, hash: a.hash }\r\n      }\r\n    }\r\n\r\n    if (a.target === '_blank') {\r\n      return\r\n    }\r\n\r\n    // Cases #1 and #2\r\n    a.addEventListener('click', e => {\r\n      if (e.ctrlKey) {\r\n        return\r\n      }\r\n\r\n      e.preventDefault()\r\n      e.stopPropagation()\r\n\r\n      // Special case when the link is a link to self. On a standard html page,\r\n      // a link to self is supposed to reload the page EXCEPT if there is an\r\n      // anchor, in which case the link acts as if it was a pure anchor link.\r\n      // One thing to take into account here is that the Docuss plugin doesn't\r\n      // support page reloading: if you call postSetDiscourseRoute() with the\r\n      // same route pageName, the page won't reload (but the hash will be set).\r\n      // So what are we gonna do?:\r\n      // - Not reloading the page is ok. I see no point in doing it. Although\r\n      // it could easily be done by setting a.target = '_parent'.\r\n      // - Scroll to the anchor must be taken care of.\r\n      if (route.pageName === page.name) {\r\n        location.hash = a.hash\r\n        const route = Object.assign({}, this.currentRoute, { hash: a.hash })\r\n        comToPlugin.postSetDiscourseRoute({\r\n          route,\r\n          mode: 'REPLACE',\r\n          clientContext: true\r\n        })\r\n      } else {\r\n        comToPlugin.postSetDiscourseRoute({\r\n          route,\r\n          mode: 'PUSH',\r\n          clientContext: true\r\n        })\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\n//==============================================================================\r\n//==============================================================================\r\n//==============================================================================\r\n\r\nfunction _scrollIntoViewIfNeeded(target) {\r\n  const rect = target.getBoundingClientRect()\r\n  // https://stackoverflow.com/a/22480938/3567351\r\n  const isPartiallyVisible = rect.top < window.innerHeight && rect.bottom >= 0\r\n  if (!isPartiallyVisible) {\r\n    // Scroll the element to the top of the window\r\n    target.scrollIntoView()\r\n\r\n    // Lower it a little bit, so that there is a nice margin between the element\r\n    // and the top of the window.\r\n    // NO, DON'T DO THAT! Suppose the element is at the bottom of the page: it\r\n    // cannot be scrolled to the top, so lowering it will make it disappear!\r\n    //window.scrollBy(0, -50)\r\n  }\r\n}\r\n\r\n//==============================================================================\r\n//==============================================================================\r\n//==============================================================================\r\n\r\nfunction _setAdditionalRedirects() {\r\n  // Remember that a same triggerId can have several node with different\r\n  // dcsHighlightable property value. So we consider a trigger as\r\n  // highligthable if any of its nodes is highligthable\r\n  const nodes = document.getElementsByClassName('dcs-trigger')\r\n  const highlightables = {}\r\n  u.dom.forEach(nodes, node => {\r\n    const triggerId = node.dataset.dcsTriggerId\r\n    highlightables[triggerId] =\r\n      highlightables[triggerId] || !!node.dataset.dcsHighlightable\r\n  })\r\n  const nonHighlitghables = Object.keys(highlightables).filter(\r\n    id => !highlightables[id]\r\n  )\r\n\r\n  // Here you might be tempted, if there are only nonHighlitghables\r\n  // triggers in the page, to set a single generic redirect instead of one\r\n  // redirect per trigger. Don't do that. Imagine the consequence if the\r\n  // page already contains a static redirect for full page commenting\r\n  // (WITH_SPLIT_BAR => FULL_CLIENT). Yep, infinite loop.\r\n  const redirects = nonHighlitghables.map(triggerId => ({\r\n    src: { layout: 2, triggerId },\r\n    dest: { layout: 0, pageName: '@SAME_AS_SRC@' }\r\n  }))\r\n  comToPlugin.postSetRedirects(redirects)\r\n}\r\n\r\n//==============================================================================\r\n//==============================================================================\r\n//==============================================================================\r\n\r\nexport const htmlBased = new HtmlBasedSingleton()\r\n\r\n//==============================================================================\r\n//==============================================================================\r\n//==============================================================================\r\n\r\n/*\r\nsetTimeout(() => {\r\n  const a1 = u.dom.createElement(`<div><a href=\"DISCOURSE/latest\">Link1 - Latest</a></div>`)\r\n  document.body.appendChild(a1)\r\n\r\n  const t = u.dom.createElement(`\r\n    <div>\r\n      <div style=\"padding: 10px 0px\" data-dcs-trigger-id=\"photos\" data-dcs-interact-mode=\"COMMENT\" data-dcs-discourse-title=\"Additional\" data-dcs-highlightable=\"true\" class=\"dcs-trigger\">\r\n        <span class=\"dcs-trigger-span\">Photos 2</span>\r\n        <span class=\"dcs-icons\">\r\n          <div class=\"dcs-balloon\"></div>\r\n        </span>\r\n      </div>\r\n    </div>\r\n  `)\r\n  document.body.appendChild(t)\r\n\r\n  const a2 = u.dom.createElement(`<a href=\"index.html\">Link2 - Home</a>`)\r\n  document.body.appendChild(a2)\r\n}, 5000)\r\n*/\r\n"],"names":["u","inIFrame","window","self","top","e","dom","onDOMReady","Promise","resolve","document","readyState","addEventListener","[object Object]","nodeList","callback","scope","list","i","length","call","wrap","el","wrapper","parentNode","insertBefore","appendChild","elArray","copyArray","Array","prototype","slice","forEach","htmlString","div","createElement","innerHTML","trim","firstChild","BellhopEventDispatcher","_listeners","name","priority","this","_priority","parseInt","indexOf","push","sort","listenerSorter","a","b","index","splice","event","data","type","Bellhop","id","Math","random","connected","isChild","connecting","origin","_sendLater","iframe","receive","_this","bind","message","target","source","onConnectionReceived","JSON","parse","err","error","trigger","postMessage","send","disconnect","HTMLIFrameElement","supported","removeEventListener","stringify","runOnce","on","internalCallback","off","parent","contentWindow","comToPlugin","_bellhop","_timer","_onConnected","clearTimeout","discourseOrigin","onConnected","timeout","onTimeout","Error","setTimeout","connect","undefined","cb","route","mode","clientContext","arguments","category","discourseTitle","redirects","scrollLimitY","max","body","scrollHeight","offsetHeight","documentElement","clientHeight","innerHeight","handleScrollEvent","scrollDirection","scrollY","preventDefault","deltaY","passive","shiftKey","altKey","ctrlKey","metaKey","code","TRIGGER_CLICK_TARGETS","_scrollIntoViewIfNeeded","rect","getBoundingClientRect","bottom","scrollIntoView","_setAdditionalRedirects","nodes","getElementsByClassName","highlightables","node","triggerId","dataset","dcsTriggerId","dcsHighlightable","Object","keys","filter","map","src","layout","dest","pageName","postSetRedirects","htmlBased","selTriggerNode","resizeTimer","currentRoute","onDiscourseRoutePushed","_onDiscourseRoutePushed","onCountsChanged","counts","console","log","reject","resolveConnect","descr","page","pages","find","p","MutationObserver","mutationsList","mutation","addedNode","addedNodes","nodeType","Node","ELEMENT_NODE","links","tagName","getElementsByTagName","_transformLink","targets","matches","querySelectorAll","t","_addTriggerClickEvent","triggers","classList","contains","observe","childList","subtree","getSelection","toString","_selectTriggers","postSetDiscourseRoute","evt","then","runReady","delayedRoute","dcsCategory","dcsDiscourseTitle","postSetRouteProps","triggerNode","closest","dcsPageName","interactMode","dcsInteractMode","stopPropagation","remove","triggerNodes","add","subsec","href","startsWith","hostname","URL","pathname","search","hash","pageUrlWithoutProxy","url","possibleRelativeLink","getAttribute","targetUrlNoProxy","websitePage","split","substring","location","assign"],"mappings":"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"}