{"version":3,"file":"dcs-html-based.js","sources":["../src/utils.js","../node_modules/bellhop-iframe/src/BellhopEventDispatcher.js","../node_modules/bellhop-iframe/src/Bellhop.js","../src/comToPlugin.js","../src/htmlBased.js","../src/dcs-html-based.js"],"sourcesContent":["//------------------------------------------------------------------------------\r\n\r\nexport const u = {}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\n// Return true if we are in an iframe\r\n// https://stackoverflow.com/a/326076/3567351\r\nu.inIFrame = () => {\r\n  try {\r\n    return window.self !== window.top\r\n  } catch (e) {\r\n    return true\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nu.dom = {\r\n  // Resolve when DOM is ready\r\n  onDOMReady() {\r\n    return new Promise(resolve => {\r\n      if (document.readyState !== 'loading') {\r\n        resolve()\r\n      } else {\r\n        document.addEventListener('DOMContentLoaded', resolve)\r\n      }\r\n    })\r\n  },\r\n\r\n  // https://github.com/imagitama/nodelist-foreach-polyfill/blob/master/index.js\r\n  forEach(nodeList, callback, scope) {\r\n    // Duplicate the list, so that we can iterate over a dynamic node list\r\n    // returned by getElementsByClassName() and the likes. If we don't, the\r\n    // following won't work, as we change the list dynamically while we iterate\r\n    // over it:\r\n    // u.dom.forEach(document.getElementsByClassName('toto'), node => node.classList.remove('toto'))\r\n    const list = [...nodeList]\r\n    for (let i = 0; i < list.length; i++) {\r\n      callback.call(scope || window, list[i], i)\r\n    }\r\n  },\r\n\r\n  wrap(el, wrapper) {\r\n    el.parentNode.insertBefore(wrapper, el)\r\n    wrapper.appendChild(el)\r\n    return wrapper\r\n  },\r\n\r\n  wrapAll(elArray, wrapper) {\r\n    if (elArray && elArray.length) {\r\n      // Duplicate the array in case it is a DOM nodeList than would be modified\r\n      // while we move elements\r\n      const copyArray = Array.prototype.slice.call(elArray)\r\n      copyArray[0].parentNode.insertBefore(wrapper, copyArray[0])\r\n      copyArray.forEach(el => wrapper.appendChild(el))\r\n    }\r\n    return wrapper\r\n  },\r\n\r\n  createElement(htmlString) {\r\n    const div = document.createElement('div')\r\n    div.innerHTML = htmlString.trim()\r\n    return div.firstChild\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n","/**\n * Function with a added priority type\n * @typedef {Function} PriorityFunction\n * @property {number} _priority\n */\n\n/**\n * Generic event dispatcher\n * @class  BellhopEventDispatcher\n */\nexport class BellhopEventDispatcher {\n  /**\n   *  The collection of event listeners\n   *  @property {Object} _listeners\n   *  @private\n   */\n  constructor() {\n    this._listeners = {};\n  }\n\n  /**\n   *  Add an event listener to the listen to an event from either the parent or iframe\n   *  @method on\n   *  @param {String} name The name of the event to listen\n   *  @param {PriorityFunction} callback The handler when an event is triggered\n   *  @param {number} [priority=0] The priority of the event listener. Higher numbers are handled first.\n   */\n  on(name, callback, priority = 0) {\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    callback._priority = parseInt(priority) || 0;\n\n    // If callback is already set to this event\n    if (-1 !== this._listeners[name].indexOf(callback)) {\n      return;\n    }\n\n    this._listeners[name].push(callback);\n\n    if (this._listeners[name].length > 1) {\n      this._listeners[name].sort(this.listenerSorter);\n    }\n  }\n\n  /**\n   * @private\n   * @param {PriorityFunction} a\n   * @param {PriorityFunction} b\n   * @returns {number};\n   *  Sorts listeners added by .on() by priority\n   */\n  listenerSorter(a, b) {\n    return a._priority - b._priority;\n  }\n\n  /**\n   *  Remove an event listener\n   *  @method off\n   *  @param {String} name The name of event to listen for. If undefined, remove all listeners.\n   *  @param {Function} [callback] The optional handler when an event is triggered, if no callback\n   *         is set then all listeners by type are removed\n   */\n  off(name, callback) {\n    if (this._listeners[name] === undefined) {\n      return;\n    }\n\n    if (callback === undefined) {\n      delete this._listeners[name];\n      return;\n    }\n\n    const index = this._listeners[name].indexOf(callback);\n\n    -1 < index ? this._listeners[name].splice(index, 1) : undefined;\n  }\n\n  /**\n   *  Trigger any event handlers for an event type\n   *  @method trigger\n   *  @param {object | String} event The event to send\n   *  @param {object} [data = {}] optional data to send to other areas in the app that are listening for this event\n   */\n  trigger(event, data = {}) {\n    if (typeof event == 'string') {\n      event = {\n        type: event,\n        data: 'object' === typeof data && null !== data ? data : {}\n      };\n    }\n\n    if ('undefined' !== typeof this._listeners[event.type]) {\n      for (let i = this._listeners[event.type].length - 1; i >= 0; i--) {\n        this._listeners[event.type][i](event);\n      }\n    }\n  }\n\n  /**\n   * Reset the listeners object\n   * @method  destroy\n   */\n  destroy() {\n    this._listeners = {};\n  }\n}\n","import { BellhopEventDispatcher } from './BellhopEventDispatcher.js';\n\n/**\n *  Abstract the communication layer between the iframe\n *  and the parent DOM\n *  @class Bellhop\n *  @extends BellhopEventDispatcher\n */\nexport class Bellhop extends BellhopEventDispatcher {\n  /**\n   * Creates an instance of Bellhop.\n   * @memberof Bellhop\n   * @param { string | number } id the id of the Bellhop instance\n   */\n  constructor(id = (Math.random() * 100) | 0) {\n    super();\n\n    /**\n     *  The instance ID for bellhop\n     *  @property {string} id\n     */\n    this.id = `BELLHOP:${id}`;\n    /**\n     *  If we are connected to another instance of the bellhop\n     *  @property {Boolean} connected\n     *  @readOnly\n     *  @default false\n     *  @private\n     */\n    this.connected = false;\n\n    /**\n     *  If this instance represents an iframe instance\n     *  @property {Boolean} isChild\n     *  @private\n     *  @default true\n     */\n    this.isChild = true;\n\n    /**\n     *  If we are current trying to connec\n     *  @property {Boolean} connecting\n     *  @default false\n     *  @private\n     */\n    this.connecting = false;\n\n    /**\n     *  If using cross-domain, the domain to post to\n     *  @property {string} origin\n     *  @private\n     *  @default \"*\"\n     */\n    this.origin = '*';\n\n    /**\n     *  Save any sends to wait until after we're done\n     *  @property {Array} _sendLater\n     *  @private\n     */\n    this._sendLater = [];\n\n    /**\n     * The iframe element\n     * @property {HTMLIFrameElement} iframe\n     * @private\n     * @readOnly\n     */\n    this.iframe = null;\n\n    /**\n     * The bound receive function\n     * @property {Function} receive\n     * @private\n     */\n    this.receive = this.receive.bind(this);\n  }\n\n  /**\n   *  The connection has been established successfully\n   *  @event connected\n   */\n\n  /**\n   *  Connection could not be established\n   *  @event failed\n   */\n\n  /**\n   *  Handle messages in the window\n   *  @method receive\n   *  @param { MessageEvent } message the post message received from another bellhop instance\n   *  @private\n   */\n  receive(message) {\n    // Ignore messages that don't originate from the target\n    // we're connected to\n    if (this.target !== message.source) {\n      return;\n    }\n\n    // If this is not the initial connection message\n    if (message.data !== 'connected') {\n      let data = message.data;\n      // Check to see if the data was sent as a stringified json\n      if ('string' === typeof data) {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          console.error('Bellhop error: ', err);\n        }\n      }\n      if (this.connected && 'object' === typeof data && data.type) {\n        this.trigger(data);\n      }\n      return;\n    }\n    // Else setup the connection\n    this.onConnectionReceived(message.data);\n  }\n  /**\n   * @memberof Bellhop\n   * @param {object} message the message received from the other bellhop instance\n   * @private\n   */\n  onConnectionReceived(message) {\n    this.connecting = false;\n    this.connected = true;\n\n    // Be polite and respond to the child that we're ready\n    if (!this.isChild) {\n      this.target.postMessage(message, this.origin);\n    }\n\n    // If we have any sends waiting to send\n    // we are now connected and it should be okay\n    for (let i = 0; i < this._sendLater.length; i++) {\n      const { type, data } = this._sendLater[i];\n      this.send(type, data);\n    }\n    this._sendLater.length = 0;\n\n    // If there is a connection event assigned call it\n    this.trigger('connected');\n  }\n\n  /**\n   *  Setup the connection\n   *  @method connect\n   *  @param {HTMLIFrameElement} iframe The iframe to communicate with. If no value is set, the assumption\n   *         is that we're the child trying to communcate with our window.parent\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\n   *  @return {Bellhop} Return instance of current object\n   */\n  connect(iframe, origin = '*') {\n    // Ignore if we're already trying to connect\n    if (this.connecting) {\n      return;\n    }\n\n    // Disconnect from any existing connection\n    this.disconnect();\n\n    // We are trying to connect\n    this.connecting = true;\n\n    // The iframe if we're the parent\n    if (iframe instanceof HTMLIFrameElement) {\n      this.iframe = iframe;\n    }\n\n    // The instance of bellhop is inside the iframe\n    this.isChild = iframe === undefined;\n\n    this.supported = true;\n    if (this.isChild) {\n      // for child pages, the window passed must be a different window\n      this.supported = window != iframe;\n    }\n\n    this.origin = origin;\n\n    window.addEventListener('message', this.receive);\n\n    if (this.isChild) {\n      // No parent, can't connect\n      if (window === this.target) {\n        this.trigger('failed');\n      } else {\n        // If connect is called after the window is ready\n        // we can go ahead and send the connect message\n        this.target.postMessage('connected', this.origin);\n      }\n    }\n  }\n\n  /**\n   *  Disconnect if there are any open connections\n   *  @method disconnect\n   */\n  disconnect() {\n    this.connected = false;\n    this.connecting = false;\n    this.origin = null;\n    this.iframe = null;\n    this.isChild = true;\n    this._sendLater.length = 0;\n\n    window.removeEventListener('message', this.receive);\n  }\n\n  /**\n   *  Send an event to the connected instance\n   *  @method send\n   *  @param {string} type name/type of the event\n   *  @param {*} [data = {}] Additional data to send along with event\n   */\n  send(type, data = {}) {\n    if (typeof type !== 'string') {\n      throw 'The event type must be a string';\n    }\n\n    const message = {\n      type,\n      data\n    };\n\n    if (this.connecting) {\n      this._sendLater.push(message);\n    } else {\n      this.target.postMessage(JSON.stringify(message), this.origin);\n    }\n  }\n\n  /**\n   *  A convenience method for sending and the listening to create\n   *  a singular link to fetching data. This is the same calling send\n   *  and then getting a response right away with the same event.\n   *  @method fetch\n   *  @param {String} event The name of the event\n   *  @param {Function} callback The callback to call after, takes event object as one argument\n   *  @param {Object} [data = {}] Optional data to pass along\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\n   */\n  fetch(event, callback, data = {}, runOnce = false) {\n    if (!this.connecting && !this.connected) {\n      throw 'No connection, please call connect() first';\n    }\n\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n\n      callback(e);\n    };\n\n    this.on(event, internalCallback);\n    this.send(event, data);\n  }\n\n  /**\n   *  A convience method for listening to an event and then responding with some data\n   *  right away. Automatically removes the listener\n   *  @method respond\n   *  @param {String} event The name of the event\n   *  @param {Object | function} [data = {}] The object to pass back.\n   *  \tMay also be a function; the return value will be sent as data in this case.\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\n   */\n  respond(event, data = {}, runOnce = false) {\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n      this.send(event, 'function' === typeof data ? data() : data);\n    };\n    this.on(event, internalCallback);\n  }\n\n  /**\n   *  Destroy and don't user after this\n   *  @method destroy\n   */\n  destroy() {\n    super.destroy();\n    this.disconnect();\n    this._sendLater.length = 0;\n  }\n\n  /**\n   *\n   * Returns the correct parent element for Bellhop's context\n   * @readonly\n   * @memberof Bellhop\n   */\n  get target() {\n    return this.isChild ? window.parent : this.iframe.contentWindow;\n  }\n}\n","import * as comTypes from './com-types'\r\nimport { Bellhop } from 'bellhop-iframe'\r\nimport { u } from './utils'\r\n\r\nexport const inIFrame = u.inIFrame\r\n\r\nclass ComToPlugin {\r\n  //----------------------------------------------------------------------------\r\n\r\n  constructor() {\r\n    this._bellhop = new Bellhop()\r\n    this._timer = null\r\n    this._onConnected = null\r\n\r\n    // This is called avery time the iframe reloads\r\n    this._bellhop.on('connected', () => {\r\n      if (this._timer) {\r\n        clearTimeout(this._timer)\r\n        this._timer = null\r\n      }\r\n      this._onConnected && this._onConnected()\r\n    })\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @param {Object} arg\r\n   * @param {string} arg.discourseOrigin\r\n   * @param {OnConnectedCallback} arg.onConnected\r\n   * @param {number} arg.timeout\r\n   * @param {OnTimeoutCallback} arg.onTimeout\r\n   */\r\n  connect({ discourseOrigin, onConnected, timeout, onTimeout }) {\r\n    if (!u.inIFrame()) {\r\n      throw new Error('comToPlugin must be used in an iframe')\r\n    }\r\n    this.disconnect()\r\n    this._onConnected = onConnected\r\n    this._timer = timeout\r\n      ? setTimeout(() => {\r\n          onTimeout && onTimeout()\r\n        }, timeout)\r\n      : null\r\n    this._bellhop.connect(undefined, discourseOrigin)\r\n  }\r\n\r\n  disconnect() {\r\n    if (this._timer) {\r\n      clearTimeout(this._timer)\r\n      this._timer = null\r\n    }\r\n    this._bellhop.disconnect()\r\n  }\r\n\r\n  isConnected() {\r\n    return this._bellhop.connected\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @callback OnDiscourseRoutePushedCallback\r\n   * @param {RoutePushedParams}\r\n   */\r\n  /**\r\n   *  @param {OnDiscourseRoutePushedCallback} cb\r\n   */\r\n  onDiscourseRoutePushed(cb) {\r\n    this._bellhop.on('m2', e => cb(e.data))\r\n  }\r\n\r\n  /**\r\n   * @callback OnCountsChangedCallback\r\n   * @param {Counts}\r\n   */\r\n  /**\r\n   *  @param {OnCountsChangedCallback} cb\r\n   */\r\n  onCountsChanged(cb) {\r\n    this._bellhop.on('m3', e => cb(e.data))\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @param {SetRouteParams}\r\n   */\r\n  postSetDiscourseRoute({ route, mode, clientContext }) {\r\n    this._bellhop.send('m4', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {SetHashParams}\r\n   */\r\n  postSetHash({ hash, mode }) {\r\n    this._bellhop.send('m5', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {RouteProps} props\r\n   */\r\n  postSetRouteProps({ category, discourseTitle, error }) {\r\n    this._bellhop.send('m6', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {[Redirect]} redirects\r\n   */\r\n  postSetRedirects(redirects) {\r\n    this._bellhop.send('m7', redirects)\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n}\r\n\r\nexport const comToPlugin = new ComToPlugin()\r\n","import { u } from './utils'\r\nimport { comToPlugin } from './comToPlugin'\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nexport { u, comToPlugin }\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nconst TRIGGER_CLICK_TARGETS =\r\n  '.dcs-icons, .dcs-trigger.dcs-no-balloon .dcs-trigger-span, .dcs-trigger.dcs-no-balloon.dcs-no-span'\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nclass HtmlBasedSingleton {\r\n  constructor() {\r\n    this.selTriggerNode = null\r\n    this.resizeTimer = null\r\n    comToPlugin.onDiscourseRoutePushed(this._onDiscourseRoutePushed.bind(this))\r\n    comToPlugin.onCountsChanged(({ counts }) => console.log('counts: ', counts))\r\n  }\r\n\r\n  connect({ discourseOrigin, timeout }) {\r\n    return new Promise((resolve, reject) => {\r\n      // Establish communication with the Discourse plugin\r\n      this.resolveConnect = resolve\r\n      comToPlugin.connect({\r\n        discourseOrigin,\r\n        timeout,\r\n        onTimeout: () => reject('timeout')\r\n      })\r\n    })\r\n  }\r\n\r\n  parseDom({ descr, pageName, discourseOrigin, counts }) {\r\n    // We will resolve all links to absolute without proxy (\"https://website.com/bar/index.html\")\r\n    // We start by retrieving the url of the current page url without the proxy\r\n    const page = descr.pages.find(p => p.name === pageName)\r\n    const pageUrlWithoutProxy = page.url\r\n\r\n    // Attempt to support more dynamic websites: manage links and trigger that\r\n    // are added later through javascript\r\n    new MutationObserver(mutationsList => {\r\n      for (let mutation of mutationsList) {\r\n        for (let addedNode of mutation.addedNodes) {\r\n          // We are interested about nodes only (not text, etc.)\r\n          if (addedNode.nodeType !== Node.ELEMENT_NODE) {\r\n            return\r\n          }\r\n\r\n          // Go through added links\r\n          const links = [\r\n            ...(addedNode.tagName === 'A' ? [addedNode] : []),\r\n            ...addedNode.getElementsByTagName('A')\r\n          ]\r\n          for (let a of links) {\r\n            console.log(\r\n              'Docuss experimental feature: a link has been dynamically added',\r\n              a\r\n            )\r\n            _transformLink({ a, descr, discourseOrigin, pageUrlWithoutProxy })\r\n          }\r\n\r\n          // Go through added click targets\r\n          const targets = [\r\n            ...(addedNode.matches(TRIGGER_CLICK_TARGETS) ? [addedNode] : []),\r\n            ...addedNode.querySelectorAll(TRIGGER_CLICK_TARGETS)\r\n          ]\r\n          for (let t of targets) {\r\n            // Case a trigger target has been dynamically added\r\n            console.log(\r\n              'Docuss experimental feature: a trigger target has been dynamically added',\r\n              t\r\n            )\r\n            this._addTriggerClickEvent({ node: t, pageName })\r\n          }\r\n\r\n          // Check if triggers have been added\r\n          const triggers = [\r\n            ...(addedNode.classList.contains('dcs-trigger') ? [addedNode] : []),\r\n            ...addedNode.getElementsByClassName('dcs-trigger')\r\n          ]\r\n          if (triggers.length) {\r\n            // Case one or several trigger nodes have been dynamically added\r\n            console.log(\r\n              'Docuss experimental feature: one or several triggers have been dynamically added',\r\n              triggers\r\n            )\r\n            _setAdditionalRedirects()\r\n          }\r\n        }\r\n      }\r\n    }).observe(document.documentElement, { childList: true, subtree: true })\r\n\r\n    // Case click nowhere special (all Docuss specific events ar handles\r\n    // elsewhere with preventDefault)\r\n    window.addEventListener('click', () => {\r\n      if (this.selTriggerNode && this.selTriggerNode.dataset.dcsHighlightable) {\r\n        this._selectTriggers(null)\r\n        comToPlugin.postSetDiscourseRoute({\r\n          route: { layout: 0, pageName },\r\n          mode: 'PUSH',\r\n          clientContext: true\r\n        })\r\n      }\r\n    })\r\n\r\n    // Resize event with debounce\r\n    // https://developer.mozilla.org/en-US/docs/Web/Events/resize#setTimeout\r\n    window.addEventListener('resize', evt => {\r\n      if (this.resizeTimer !== null) {\r\n        clearTimeout(this.resizeTimer)\r\n      }\r\n      this.resizeTimer = setTimeout(() => {\r\n        this.resizeTimer = null\r\n        if (this.selTriggerNode) {\r\n          _scrollIntoViewIfNeeded(this.selTriggerNode)\r\n        }\r\n      }, 100)\r\n    })\r\n\r\n    return u.dom.onDOMReady().then(() => {\r\n      // Modify the document links so that they open the correct url in the\r\n      // correct place\r\n      u.dom.forEach(document.getElementsByTagName('a'), a => {\r\n        _transformLink({ a, descr, discourseOrigin, pageUrlWithoutProxy })\r\n      })\r\n\r\n      // Add click events on triggers\r\n      u.dom.forEach(document.querySelectorAll(TRIGGER_CLICK_TARGETS), node => {\r\n        this._addTriggerClickEvent({ node, pageName })\r\n      })\r\n\r\n      // Set the additional redirects\r\n      _setAdditionalRedirects()\r\n\r\n      this.runReady = true\r\n\r\n      if (this.delayedRoute) {\r\n        this._onDiscourseRoutePushed({ route: this.delayedRoute })\r\n      }\r\n    })\r\n  }\r\n\r\n  _onDiscourseRoutePushed({ route, descr, counts, clientContext, origin }) {\r\n    // Case init\r\n    if (this.resolveConnect) {\r\n      this.resolveConnect({\r\n        descr,\r\n        pageName: route.pageName,\r\n        discourseOrigin: origin,\r\n        counts\r\n      })\r\n      delete this.resolveConnect\r\n      this.runReady = false\r\n      this.delayedRoute = route\r\n      return\r\n    }\r\n\r\n    // Case we're still not ready\r\n    if (!this.runReady) {\r\n      this.delayedRoute = route\r\n      return\r\n    }\r\n\r\n    // Set the route category and title\r\n    if (route.layout === 2 || route.layout === 3) {\r\n      // clientContext === true means that this route changed has been\r\n      // triggered by us, so there is nothing more we need to do (because the\r\n      // trigger is already selected)\r\n      if (!clientContext) {\r\n        this._selectTriggers(route.triggerId)\r\n      }\r\n\r\n      // Set the route props\r\n      const category =\r\n        (this.selTriggerNode && this.selTriggerNode.dataset.dcsCategory) ||\r\n        document.documentElement.dataset.dcsCategory\r\n      const discourseTitle =\r\n        (this.selTriggerNode &&\r\n          this.selTriggerNode.dataset.dcsDiscourseTitle) ||\r\n        document.documentElement.dataset.dcsDiscourseTitle\r\n      comToPlugin.postSetRouteProps({ category, discourseTitle })\r\n    }\r\n  }\r\n\r\n  _addTriggerClickEvent({ node, pageName }) {\r\n    node.addEventListener('click', e => {\r\n      // Don't do anything if user is selecting text\r\n      if (window.getSelection().toString()) {\r\n        return\r\n      }\r\n\r\n      const triggerNode = e.target.closest('.dcs-trigger')\r\n      const triggerId = triggerNode.dataset.dcsTriggerId\r\n\r\n      this._selectTriggers(triggerId)\r\n\r\n      comToPlugin.postSetDiscourseRoute({\r\n        route: {\r\n          layout: 3,\r\n          pageName: triggerNode.dataset.dcsPageName || pageName,\r\n          triggerId,\r\n          interactMode: triggerNode.dataset.dcsInteractMode\r\n        },\r\n        mode: 'PUSH',\r\n        clientContext: true\r\n      })\r\n\r\n      // Mandatory because we want our global click event to fire only\r\n      // when user clicks on an empty space\r\n      e.stopPropagation()\r\n    })\r\n  }\r\n\r\n  // Remember there can be more than one trigger per triggerId\r\n  _selectTriggers(triggerId) {\r\n    if (!this.runReady) {\r\n      throw new Error('should be ready')\r\n    }\r\n\r\n    // Unselect everything\r\n    this.selTriggerNode = null\r\n    u.dom.forEach(document.getElementsByClassName('dcs-highlighted'), node =>\r\n      node.classList.remove('dcs-highlighted')\r\n    )\r\n\r\n    // Case there is nothing to select\r\n    if (!triggerId) {\r\n      return\r\n    }\r\n\r\n    // Look for the trigger node in the DOM\r\n    const triggerNodes = document.querySelectorAll(\r\n      `.dcs-trigger[data-dcs-trigger-id=\"${triggerId}\"]`\r\n    )\r\n\r\n    // Case tag not found\r\n    if (!triggerNodes.length) {\r\n      comToPlugin.postSetRouteProps({ error })\r\n      return\r\n    }\r\n\r\n    // Go through selected nodes\r\n    this.selTriggerNode = null\r\n    u.dom.forEach(triggerNodes, node => {\r\n      // Is it a highlightable trigger node?\r\n      if (node.dataset.dcsHighlightable) {\r\n        // Highlight the trigger nodes\r\n        node.classList.add('dcs-highlighted')\r\n\r\n        // Highlight the subsec nodes\r\n        const subsec = node.closest('.dcs-subsec')\r\n        subsec && subsec.classList.add('dcs-highlighted')\r\n\r\n        // Set one node as the selected one, with priority given to the first\r\n        // dcsHighlightable one. THIS IS IMPORTANT: the selected node must be a\r\n        // dcsHighlightable one for the default click handler to work correctly.\r\n        this.selTriggerNode = this.selTriggerNode || node\r\n      }\r\n    })\r\n\r\n    // Case no dcsHighlightable has been found: take the first node\r\n    this.selTriggerNode = this.selTriggerNode || triggerNodes[0]\r\n\r\n    // Bring the selected node into view\r\n    // THIS IS REQUIRED WHEN LAYOUT HAS CHANGED, BUT ALSO WHEN USING THE BACK\r\n    // BUTTON TO A PREVIOUSLY SELECTED HEADING FAR AWAY\r\n    // Need a setTimeout, to ensure the layout change has occurred.\r\n    // 200 is the iframes animation duration + 30 for security\r\n    // +300 because some web sites (ex: VueJS API) have an animation when layout\r\n    // changes from narrow to wide screen.\r\n    setTimeout(() => _scrollIntoViewIfNeeded(this.selTriggerNode), 700)\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nfunction _scrollIntoViewIfNeeded(target) {\r\n  const rect = target.getBoundingClientRect()\r\n  // https://stackoverflow.com/a/22480938/3567351\r\n  const isPartiallyVisible = rect.top < window.innerHeight && rect.bottom >= 0\r\n  if (!isPartiallyVisible) {\r\n    // Scroll the element to the top of the window\r\n    target.scrollIntoView()\r\n\r\n    // Lower it a little bit, so that there is a nice margin between the element\r\n    // and the top of the window.\r\n    // NO, DON'T DO THAT! Suppose the element is at the bottom of the page: it\r\n    // cannot be scrolled to the top, so lowering it will make it disappear!\r\n    //window.scrollBy(0, -50)\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nfunction _transformLink({ a, descr, discourseOrigin, pageUrlWithoutProxy }) {\r\n  // Case link is empty\r\n  if (\r\n    !a.href ||\r\n    a.href === '#' ||\r\n    a.href === '#!' || // Yes, some people use this for empty links!\r\n    a.href.startsWith('javascript:')\r\n  ) {\r\n    return\r\n  }\r\n\r\n  // Clean the link, so that it's easier to handle later:\r\n  // - Replace the DISCOURSE placeholder by the full link\r\n  // - Convert from relative to absolute without proxy\r\n  // - Remove inappropriate target\r\n  const href = a.getAttribute('href').trim()\r\n  if (href.startsWith('DISCOURSE/')) {\r\n    a.href = discourseOrigin + href.substring('DISCOURSE/'.length - 1)\r\n  } else {\r\n    a.href = new URL(href, pageUrlWithoutProxy)\r\n  }\r\n  if (a.target === '_parent' || a.target === '_top') {\r\n    delete a.target\r\n  }\r\n\r\n  // Case the link is a discourse link: cancel the behavior and set a\r\n  // custom click handler\r\n  if (a.origin === discourseOrigin) {\r\n    a.addEventListener('click', e => {\r\n      e.preventDefault()\r\n      e.stopPropagation()\r\n      comToPlugin.postSetDiscourseRoute({\r\n        route: { layout: 1, pathname: a.pathname },\r\n        mode: 'PUSH',\r\n        clientContext: true\r\n      })\r\n    })\r\n    return\r\n  }\r\n\r\n  const targetUrlNoHash = a.href.split('#')[0]\r\n\r\n  // Case it is an anchor (internal link)\r\n  if (a.hash && targetUrlNoHash === pageUrlWithoutProxy.split('#')[0]) {\r\n    // We need to notify the parent window AND keep the default anchor behavior\r\n    a.addEventListener('click', () => {\r\n      comToPlugin.postSetHash({ hash: a.hash, mode: 'REPLACE' })\r\n    })\r\n    return\r\n  }\r\n\r\n  // Case it is an external link or a link to self\r\n\r\n  // See if there is a corresponding page in the website\r\n  const page = descr.pages.find(p => p.url.split('#')[0] === targetUrlNoHash)\r\n\r\n  // Case the external link points to an arbitrary external target (no\r\n  // page found)\r\n  if (!page) {\r\n    if (!a.target || a.target === '_self') {\r\n      a.target = '_parent'\r\n    }\r\n    return\r\n  }\r\n\r\n  // Case the external link points to another page of the website (or\r\n  // to self)\r\n\r\n  // Change the href so that cmd+click or right click+... will open\r\n  // the Discourse instance in another tab\r\n  a.href = discourseOrigin + '/docuss/' + page.name + a.hash\r\n\r\n  // Regarding the simple click, cancel the default behavior and\r\n  // let Discourse load the target page\r\n  if (!a.target || a.target === '_self') {\r\n    a.addEventListener('click', e => {\r\n      e.preventDefault()\r\n      e.stopPropagation()\r\n      comToPlugin.postSetDiscourseRoute({\r\n        route: { layout: 0, pageName: page.name },\r\n        mode: 'PUSH',\r\n        clientContext: true\r\n      })\r\n    })\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nfunction _setAdditionalRedirects() {\r\n  // Remember that a same triggerId can have several node with different\r\n  // dcsHighlightable property value. So we consider a trigger as\r\n  // highligthable if any of its nodes is highligthable\r\n  const nodes = document.getElementsByClassName('dcs-trigger')\r\n  const highlightables = {}\r\n  u.dom.forEach(nodes, node => {\r\n    const triggerId = node.dataset.dcsTriggerId\r\n    highlightables[triggerId] =\r\n      highlightables[triggerId] || !!node.dataset.dcsHighlightable\r\n  })\r\n  const nonHighlitghables = Object.keys(highlightables).filter(\r\n    id => !highlightables[id]\r\n  )\r\n\r\n  // Here you might be tempted, if there are only nonHighlitghables\r\n  // triggers in the page, to set a single generic redirect instead of one\r\n  // redirect per trigger. Don't do that. Imagine the consequence if the\r\n  // page already contains a static redirect for full page commenting\r\n  // (WITH_SPLIT_BAR => FULL_CLIENT). Yep, infinite loop.\r\n  const redirects = nonHighlitghables.map(triggerId => ({\r\n    src: { layout: 2, triggerId },\r\n    dest: { layout: 0, pageName: '@SAME_AS_SRC@' }\r\n  }))\r\n  comToPlugin.postSetRedirects(redirects)\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nexport const htmlBased = new HtmlBasedSingleton()\r\n\r\n//------------------------------------------------------------------------------\r\n\r\n/*\r\nsetTimeout(() => {\r\n  const a1 = u.dom.createElement(`<div><a href=\"DISCOURSE/latest\">Link1 - Latest</a></div>`)\r\n  document.body.appendChild(a1)\r\n\r\n  const t = u.dom.createElement(`\r\n    <div>\r\n      <div style=\"padding: 10px 0px\" data-dcs-trigger-id=\"photos\" data-dcs-interact-mode=\"COMMENT\" data-dcs-discourse-title=\"Additional\" data-dcs-highlightable=\"true\" class=\"dcs-trigger\">\r\n        <span class=\"dcs-trigger-span\">Photos 2</span>\r\n        <span class=\"dcs-icons\">\r\n          <div class=\"dcs-balloon\"></div>\r\n        </span>\r\n      </div>\r\n    </div>\r\n  `)\r\n  document.body.appendChild(t)\r\n\r\n  const a2 = u.dom.createElement(`<a href=\"index.html\">Link2 - Home</a>`)\r\n  document.body.appendChild(a2)\r\n}, 5000)\r\n*/\r\n","import { htmlBased } from './htmlBased'\r\n\r\nhtmlBased.connect({ discourseOrigin: '*', timeout: 10000 }).then(\r\n  args => {\r\n    htmlBased.parseDom(args)\r\n  },\r\n  e => logError('Unable to connect to dcs-discourse-plugin2', e)\r\n)\r\n"],"names":["u","inIFrame","window","self","top","e","dom","onDOMReady","Promise","resolve","document","readyState","addEventListener","[object Object]","nodeList","callback","scope","list","i","length","call","wrap","el","wrapper","parentNode","insertBefore","appendChild","elArray","copyArray","Array","prototype","slice","forEach","htmlString","div","createElement","innerHTML","trim","firstChild","BellhopEventDispatcher","_listeners","name","priority","this","_priority","parseInt","indexOf","push","sort","listenerSorter","a","b","index","splice","event","data","type","Bellhop","id","Math","random","connected","isChild","connecting","origin","_sendLater","iframe","receive","_this","bind","message","target","source","onConnectionReceived","JSON","parse","err","error","trigger","postMessage","send","disconnect","HTMLIFrameElement","supported","removeEventListener","stringify","runOnce","on","internalCallback","off","parent","contentWindow","comToPlugin","_bellhop","_timer","_onConnected","clearTimeout","discourseOrigin","onConnected","timeout","onTimeout","Error","setTimeout","connect","undefined","cb","route","mode","clientContext","arguments","hash","category","discourseTitle","redirects","TRIGGER_CLICK_TARGETS","_scrollIntoViewIfNeeded","rect","getBoundingClientRect","innerHeight","bottom","scrollIntoView","_transformLink","descr","pageUrlWithoutProxy","href","startsWith","getAttribute","substring","URL","preventDefault","stopPropagation","postSetDiscourseRoute","layout","pathname","targetUrlNoHash","split","postSetHash","page","pages","find","p","url","pageName","_setAdditionalRedirects","nodes","getElementsByClassName","highlightables","node","triggerId","dataset","dcsTriggerId","dcsHighlightable","Object","keys","filter","map","src","dest","postSetRedirects","htmlBased","selTriggerNode","resizeTimer","onDiscourseRoutePushed","_onDiscourseRoutePushed","onCountsChanged","counts","console","log","reject","resolveConnect","MutationObserver","mutationsList","mutation","addedNode","addedNodes","nodeType","Node","ELEMENT_NODE","links","tagName","getElementsByTagName","targets","matches","querySelectorAll","t","_addTriggerClickEvent","triggers","classList","contains","observe","documentElement","childList","subtree","_selectTriggers","evt","then","runReady","delayedRoute","dcsCategory","dcsDiscourseTitle","postSetRouteProps","getSelection","toString","triggerNode","closest","dcsPageName","interactMode","dcsInteractMode","remove","triggerNodes","add","subsec","args","parseDom","logError"],"mappings":"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"}