{"version":3,"file":"dcs-html-based.js","sources":["../src/utils.js","../node_modules/bellhop-iframe/src/BellhopEventDispatcher.js","../node_modules/bellhop-iframe/src/Bellhop.js","../src/comToPlugin.js","../src/htmlBased.js","../src/dcs-html-based.js"],"sourcesContent":["//------------------------------------------------------------------------------\r\n\r\nexport const u = {}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\n// Return true if we are in an iframe\r\n// https://stackoverflow.com/a/326076/3567351\r\nu.inIFrame = () => {\r\n  try {\r\n    return window.self !== window.top\r\n  } catch (e) {\r\n    return true\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nu.dom = {\r\n  // Resolve when DOM is ready\r\n  onDOMReady() {\r\n    return new Promise(resolve => {\r\n      if (document.readyState !== 'loading') {\r\n        resolve()\r\n      } else {\r\n        document.addEventListener('DOMContentLoaded', resolve)\r\n      }\r\n    })\r\n  },\r\n\r\n  // https://github.com/imagitama/nodelist-foreach-polyfill/blob/master/index.js\r\n  forEach(nodeList, callback, scope) {\r\n    // Duplicate the list, so that we can iterate over a dynamic node list\r\n    // returned by getElementsByClassName() and the likes. If we don't, the\r\n    // following won't work, as we change the list dynamically while we iterate\r\n    // over it:\r\n    // u.dom.forEach(document.getElementsByClassName('toto'), node => node.classList.remove('toto'))\r\n    const list = [...nodeList]\r\n    for (let i = 0; i < list.length; i++) {\r\n      callback.call(scope || window, list[i], i)\r\n    }\r\n  },\r\n\r\n  wrap(el, wrapper) {\r\n    el.parentNode.insertBefore(wrapper, el)\r\n    wrapper.appendChild(el)\r\n    return wrapper\r\n  },\r\n\r\n  wrapAll(elArray, wrapper) {\r\n    if (elArray && elArray.length) {\r\n      // Duplicate the array in case it is a DOM nodeList than would be modified\r\n      // while we move elements\r\n      const copyArray = Array.prototype.slice.call(elArray)\r\n      copyArray[0].parentNode.insertBefore(wrapper, copyArray[0])\r\n      copyArray.forEach(el => wrapper.appendChild(el))\r\n    }\r\n    return wrapper\r\n  },\r\n\r\n  createElement(htmlString) {\r\n    const div = document.createElement('div')\r\n    div.innerHTML = htmlString.trim()\r\n    return div.firstChild\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n","/**\n * Function with a added priority type\n * @typedef {Function} PriorityFunction\n * @property {number} _priority\n */\n\n/**\n * Generic event dispatcher\n * @class  BellhopEventDispatcher\n */\nexport class BellhopEventDispatcher {\n  /**\n   *  The collection of event listeners\n   *  @property {Object} _listeners\n   *  @private\n   */\n  constructor() {\n    this._listeners = {};\n  }\n\n  /**\n   *  Add an event listener to the listen to an event from either the parent or iframe\n   *  @method on\n   *  @param {String} name The name of the event to listen\n   *  @param {PriorityFunction} callback The handler when an event is triggered\n   *  @param {number} [priority=0] The priority of the event listener. Higher numbers are handled first.\n   */\n  on(name, callback, priority = 0) {\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    callback._priority = parseInt(priority) || 0;\n\n    // If callback is already set to this event\n    if (-1 !== this._listeners[name].indexOf(callback)) {\n      return;\n    }\n\n    this._listeners[name].push(callback);\n\n    if (this._listeners[name].length > 1) {\n      this._listeners[name].sort(this.listenerSorter);\n    }\n  }\n\n  /**\n   * @private\n   * @param {PriorityFunction} a\n   * @param {PriorityFunction} b\n   * @returns {number};\n   *  Sorts listeners added by .on() by priority\n   */\n  listenerSorter(a, b) {\n    return a._priority - b._priority;\n  }\n\n  /**\n   *  Remove an event listener\n   *  @method off\n   *  @param {String} name The name of event to listen for. If undefined, remove all listeners.\n   *  @param {Function} [callback] The optional handler when an event is triggered, if no callback\n   *         is set then all listeners by type are removed\n   */\n  off(name, callback) {\n    if (this._listeners[name] === undefined) {\n      return;\n    }\n\n    if (callback === undefined) {\n      delete this._listeners[name];\n      return;\n    }\n\n    const index = this._listeners[name].indexOf(callback);\n\n    -1 < index ? this._listeners[name].splice(index, 1) : undefined;\n  }\n\n  /**\n   *  Trigger any event handlers for an event type\n   *  @method trigger\n   *  @param {object | String} event The event to send\n   *  @param {object} [data = {}] optional data to send to other areas in the app that are listening for this event\n   */\n  trigger(event, data = {}) {\n    if (typeof event == 'string') {\n      event = {\n        type: event,\n        data: 'object' === typeof data && null !== data ? data : {}\n      };\n    }\n\n    if ('undefined' !== typeof this._listeners[event.type]) {\n      for (let i = this._listeners[event.type].length - 1; i >= 0; i--) {\n        this._listeners[event.type][i](event);\n      }\n    }\n  }\n\n  /**\n   * Reset the listeners object\n   * @method  destroy\n   */\n  destroy() {\n    this._listeners = {};\n  }\n}\n","import { BellhopEventDispatcher } from './BellhopEventDispatcher.js';\n\n/**\n *  Abstract the communication layer between the iframe\n *  and the parent DOM\n *  @class Bellhop\n *  @extends BellhopEventDispatcher\n */\nexport class Bellhop extends BellhopEventDispatcher {\n  /**\n   * Creates an instance of Bellhop.\n   * @memberof Bellhop\n   * @param { string | number } id the id of the Bellhop instance\n   */\n  constructor(id = (Math.random() * 100) | 0) {\n    super();\n\n    /**\n     *  The instance ID for bellhop\n     *  @property {string} id\n     */\n    this.id = `BELLHOP:${id}`;\n    /**\n     *  If we are connected to another instance of the bellhop\n     *  @property {Boolean} connected\n     *  @readOnly\n     *  @default false\n     *  @private\n     */\n    this.connected = false;\n\n    /**\n     *  If this instance represents an iframe instance\n     *  @property {Boolean} isChild\n     *  @private\n     *  @default true\n     */\n    this.isChild = true;\n\n    /**\n     *  If we are current trying to connec\n     *  @property {Boolean} connecting\n     *  @default false\n     *  @private\n     */\n    this.connecting = false;\n\n    /**\n     *  If using cross-domain, the domain to post to\n     *  @property {string} origin\n     *  @private\n     *  @default \"*\"\n     */\n    this.origin = '*';\n\n    /**\n     *  Save any sends to wait until after we're done\n     *  @property {Array} _sendLater\n     *  @private\n     */\n    this._sendLater = [];\n\n    /**\n     * The iframe element\n     * @property {HTMLIFrameElement} iframe\n     * @private\n     * @readOnly\n     */\n    this.iframe = null;\n\n    /**\n     * The bound receive function\n     * @property {Function} receive\n     * @private\n     */\n    this.receive = this.receive.bind(this);\n  }\n\n  /**\n   *  The connection has been established successfully\n   *  @event connected\n   */\n\n  /**\n   *  Connection could not be established\n   *  @event failed\n   */\n\n  /**\n   *  Handle messages in the window\n   *  @method receive\n   *  @param { MessageEvent } message the post message received from another bellhop instance\n   *  @private\n   */\n  receive(message) {\n    // Ignore messages that don't originate from the target\n    // we're connected to\n    if (this.target !== message.source) {\n      return;\n    }\n\n    // If this is not the initial connection message\n    if (message.data !== 'connected') {\n      let data = message.data;\n      // Check to see if the data was sent as a stringified json\n      if ('string' === typeof data) {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          console.error('Bellhop error: ', err);\n        }\n      }\n      if (this.connected && 'object' === typeof data && data.type) {\n        this.trigger(data);\n      }\n      return;\n    }\n    // Else setup the connection\n    this.onConnectionReceived(message.data);\n  }\n  /**\n   * @memberof Bellhop\n   * @param {object} message the message received from the other bellhop instance\n   * @private\n   */\n  onConnectionReceived(message) {\n    this.connecting = false;\n    this.connected = true;\n\n    // Be polite and respond to the child that we're ready\n    if (!this.isChild) {\n      this.target.postMessage(message, this.origin);\n    }\n\n    // If we have any sends waiting to send\n    // we are now connected and it should be okay\n    for (let i = 0; i < this._sendLater.length; i++) {\n      const { type, data } = this._sendLater[i];\n      this.send(type, data);\n    }\n    this._sendLater.length = 0;\n\n    // If there is a connection event assigned call it\n    this.trigger('connected');\n  }\n\n  /**\n   *  Setup the connection\n   *  @method connect\n   *  @param {HTMLIFrameElement} iframe The iframe to communicate with. If no value is set, the assumption\n   *         is that we're the child trying to communcate with our window.parent\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\n   *  @return {Bellhop} Return instance of current object\n   */\n  connect(iframe, origin = '*') {\n    // Ignore if we're already trying to connect\n    if (this.connecting) {\n      return;\n    }\n\n    // Disconnect from any existing connection\n    this.disconnect();\n\n    // We are trying to connect\n    this.connecting = true;\n\n    // The iframe if we're the parent\n    if (iframe instanceof HTMLIFrameElement) {\n      this.iframe = iframe;\n    }\n\n    // The instance of bellhop is inside the iframe\n    this.isChild = iframe === undefined;\n\n    this.supported = true;\n    if (this.isChild) {\n      // for child pages, the window passed must be a different window\n      this.supported = window != iframe;\n    }\n\n    this.origin = origin;\n\n    window.addEventListener('message', this.receive);\n\n    if (this.isChild) {\n      // No parent, can't connect\n      if (window === this.target) {\n        this.trigger('failed');\n      } else {\n        // If connect is called after the window is ready\n        // we can go ahead and send the connect message\n        this.target.postMessage('connected', this.origin);\n      }\n    }\n  }\n\n  /**\n   *  Disconnect if there are any open connections\n   *  @method disconnect\n   */\n  disconnect() {\n    this.connected = false;\n    this.connecting = false;\n    this.origin = null;\n    this.iframe = null;\n    this.isChild = true;\n    this._sendLater.length = 0;\n\n    window.removeEventListener('message', this.receive);\n  }\n\n  /**\n   *  Send an event to the connected instance\n   *  @method send\n   *  @param {string} type name/type of the event\n   *  @param {*} [data = {}] Additional data to send along with event\n   */\n  send(type, data = {}) {\n    if (typeof type !== 'string') {\n      throw 'The event type must be a string';\n    }\n\n    const message = {\n      type,\n      data\n    };\n\n    if (this.connecting) {\n      this._sendLater.push(message);\n    } else {\n      this.target.postMessage(JSON.stringify(message), this.origin);\n    }\n  }\n\n  /**\n   *  A convenience method for sending and the listening to create\n   *  a singular link to fetching data. This is the same calling send\n   *  and then getting a response right away with the same event.\n   *  @method fetch\n   *  @param {String} event The name of the event\n   *  @param {Function} callback The callback to call after, takes event object as one argument\n   *  @param {Object} [data = {}] Optional data to pass along\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\n   */\n  fetch(event, callback, data = {}, runOnce = false) {\n    if (!this.connecting && !this.connected) {\n      throw 'No connection, please call connect() first';\n    }\n\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n\n      callback(e);\n    };\n\n    this.on(event, internalCallback);\n    this.send(event, data);\n  }\n\n  /**\n   *  A convience method for listening to an event and then responding with some data\n   *  right away. Automatically removes the listener\n   *  @method respond\n   *  @param {String} event The name of the event\n   *  @param {Object | function} [data = {}] The object to pass back.\n   *  \tMay also be a function; the return value will be sent as data in this case.\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\n   */\n  respond(event, data = {}, runOnce = false) {\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n      this.send(event, 'function' === typeof data ? data() : data);\n    };\n    this.on(event, internalCallback);\n  }\n\n  /**\n   *  Destroy and don't user after this\n   *  @method destroy\n   */\n  destroy() {\n    super.destroy();\n    this.disconnect();\n    this._sendLater.length = 0;\n  }\n\n  /**\n   *\n   * Returns the correct parent element for Bellhop's context\n   * @readonly\n   * @memberof Bellhop\n   */\n  get target() {\n    return this.isChild ? window.parent : this.iframe.contentWindow;\n  }\n}\n","import * as comTypes from './com-types'\r\nimport { Bellhop } from 'bellhop-iframe'\r\nimport { u } from './utils'\r\n\r\nexport const inIFrame = u.inIFrame\r\n\r\nclass ComToPlugin {\r\n  //----------------------------------------------------------------------------\r\n\r\n  constructor() {\r\n    this._bellhop = new Bellhop()\r\n    this._timer = null\r\n    this._onConnected = null\r\n\r\n    // This is called avery time the iframe reloads\r\n    this._bellhop.on('connected', () => {\r\n      if (this._timer) {\r\n        clearTimeout(this._timer)\r\n        this._timer = null\r\n      }\r\n      this._onConnected && this._onConnected()\r\n    })\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @param {Object} arg\r\n   * @param {string} arg.discourseOrigin\r\n   * @param {OnConnectedCallback} arg.onConnected\r\n   * @param {number} arg.timeout\r\n   * @param {OnTimeoutCallback} arg.onTimeout\r\n   */\r\n\r\n  connect({ discourseOrigin, onConnected, timeout, onTimeout }) {\r\n    if (!u.inIFrame()) {\r\n      throw new Error('comToPlugin must be used in an iframe')\r\n    }\r\n    this.disconnect()\r\n    this._onConnected = onConnected\r\n    this._timer = timeout\r\n      ? setTimeout(() => {\r\n          onTimeout && onTimeout()\r\n        }, timeout)\r\n      : null\r\n    this._bellhop.connect(undefined, discourseOrigin)\r\n  }\r\n\r\n  disconnect() {\r\n    if (this._timer) {\r\n      clearTimeout(this._timer)\r\n      this._timer = null\r\n    }\r\n    this._bellhop.disconnect()\r\n  }\r\n\r\n  isConnected() {\r\n    return this._bellhop.connected\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @callback OnDiscourseRoutePushedCallback\r\n   * @param {RouteAndDescrAndCountsAndContext}\r\n   */\r\n  /**\r\n   *  @param {OnDiscourseRoutePushedCallback} cb\r\n   */\r\n  onDiscourseRoutePushed(cb) {\r\n    this._bellhop.on('m2', e => cb(e.data))\r\n  }\r\n\r\n  /**\r\n   * @callback OnCountsChangedCallback\r\n   * @param {Counts}\r\n   */\r\n  /**\r\n   *  @param {OnCountsChangedCallback} cb\r\n   */\r\n  onCountsChanged(cb) {\r\n    this._bellhop.on('m3', e => cb(e.data))\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @param {RouteAndModeAndContext}\r\n   */\r\n  postSetDiscourseRoute({ route, mode, clientContext }) {\r\n    this._bellhop.send('m4', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {HashAndMode}\r\n   */\r\n  postSetHash({ hash, mode }) {\r\n    this._bellhop.send('m5', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {RouteProps} props\r\n   */\r\n  postSetRouteProps({ category, discourseTitle, error }) {\r\n    this._bellhop.send('m6', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {[Redirect]} redirects\r\n   */\r\n  postSetRedirects(redirects) {\r\n    this._bellhop.send('m7', redirects)\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n}\r\n\r\nexport const comToPlugin = new ComToPlugin()\r\n","import { u } from './utils'\r\nimport { comToPlugin } from './comToPlugin'\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nexport { u, comToPlugin }\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nclass HtmlBased {\r\n  constructor() {\r\n    this.selTriggerNode = null\r\n    this.resizeTimer = null\r\n    comToPlugin.onDiscourseRoutePushed(this._onDiscourseRoutePushed.bind(this))\r\n    comToPlugin.onCountsChanged(({ counts }) => console.log('counts: ', counts))\r\n  }\r\n\r\n  connect({ discourseOrigin, timeout }) {\r\n    return new Promise((resolve, reject) => {\r\n      // Establish communication with the Discourse plugin\r\n      this.resolveInit = resolve\r\n      comToPlugin.connect({\r\n        discourseOrigin,\r\n        timeout,\r\n        onTimeout: () => reject('timeout')\r\n      })\r\n    })\r\n  }\r\n\r\n  parseDom({ descr, pageName, discourseUrl, counts }) {\r\n    // We will resolve all links to absolute without proxy (\"https://website.com/bar/index.html\")\r\n    // We start by retrieving the url of the current page url without the proxy\r\n    const page = descr.staticPages.find(p => p.name === pageName)\r\n    const pageUrlWithoutProxy = page.url\r\n\r\n    const discourseOrigin = new URL(discourseUrl).origin\r\n\r\n    return u.dom.onDOMReady().then(() => {\r\n      // Modify the document links so that they open the correct url in the\r\n      // correct place\r\n      u.dom.forEach(document.getElementsByTagName('a'), a => {\r\n        // Case link is empty\r\n        if (!a.href || a.href === '#' || a.href.startsWith('javascript:')) {\r\n          return\r\n        }\r\n\r\n        // Clean the link, so that it's easier to handle later:\r\n        // - Replace the DISCOURSE placeholder by the full link\r\n        // - Convert from relative to absolute without proxy\r\n        // - Remove inappropriate target\r\n        const href = a.getAttribute('href').trim()\r\n        if (href.startsWith('DISCOURSE/')) {\r\n          a.href = discourseOrigin + href.substring('DISCOURSE/'.length - 1)\r\n        } else {\r\n          a.href = new URL(href, pageUrlWithoutProxy)\r\n        }\r\n        if (a.target === '_parent' || a.target === '_top') {\r\n          delete a.target\r\n        }\r\n\r\n        // Case the link is a discourse link: cancel the behavior and set a\r\n        // custom click handler\r\n        if (a.origin === discourseOrigin) {\r\n          a.onclick = e => {\r\n            e.preventDefault()\r\n            e.stopPropagation()\r\n            comToPlugin.postSetDiscourseRoute({\r\n              route: { layout: 'FULL_DISCOURSE', url: a.href },\r\n              mode: 'PUSH',\r\n              clientContext: true\r\n            })\r\n          }\r\n          return\r\n        }\r\n\r\n        const targetUrlNoHash = a.href.split('#')[0]\r\n\r\n        // Case it is an anchor (internal link)\r\n        if (a.hash && targetUrlNoHash === pageUrlWithoutProxy.split('#')[0]) {\r\n          // We need to notify the parent window AND keep the default anchor behavior\r\n          a.onclick = () => {\r\n            comToPlugin.postSetHash({ hash: a.hash, mode: 'REPLACE' })\r\n          }\r\n          return\r\n        }\r\n\r\n        // Case it is an external link or a link to self\r\n\r\n        // See if there is a corresponding page in the website\r\n        const page = descr.staticPages.find(\r\n          p => p.url.split('#')[0] === targetUrlNoHash\r\n        )\r\n\r\n        // Case the external link points to an arbitrary external target (no\r\n        // page found)\r\n        if (!page) {\r\n          if (!a.target || a.target === '_self') {\r\n            a.target = '_parent'\r\n          }\r\n          return\r\n        }\r\n\r\n        // Case the external link points to another page of the website (or\r\n        // to self)\r\n\r\n        // Change the href so that cmd+click or right click+... will open\r\n        // the Discourse instance in another tab\r\n        a.href = discourseOrigin + '/docuss/' + page.name + a.hash\r\n\r\n        // Regarding the simple click, cancel the default behavior and\r\n        // let Discourse load the target page\r\n        if (!a.target || a.target === '_self') {\r\n          a.onclick = e => {\r\n            e.preventDefault()\r\n            e.stopPropagation()\r\n            comToPlugin.postSetDiscourseRoute({\r\n              route: { layout: 'FULL_CLIENT', pageName: page.name },\r\n              mode: 'PUSH',\r\n              clientContext: true\r\n            })\r\n          }\r\n        }\r\n      })\r\n\r\n      // Set the additional redirects\r\n      // Remember that a same triggerId can have several node with different\r\n      // dcsHighlightable property value. So we consider a trigger as\r\n      // highligthable if any of its nodes is highligthable\r\n      const nodes = document.getElementsByClassName('dcs-trigger')\r\n      const ids = {}\r\n      u.dom.forEach(nodes, node => {\r\n        const triggerId = node.dataset.dcsTriggerId\r\n        const highlightable = ids[triggerId] || !!node.dataset.dcsHighlightable\r\n        ids[triggerId] = highlightable\r\n      })\r\n      const nonHighlitghables = Object.keys(ids).filter(id => !ids[id])\r\n      // Here you might be tempted, if there are only nonHighlitghables\r\n      // triggers in the page, to set a single generic redirect instead of one\r\n      // redirect per trigger. Don't do that. Imagine the consequence if the\r\n      // page already contains a static redirect for full page commenting\r\n      // (WITH_SPLIT_BAR => FULL_CLIENT). Yep, infinite loop.\r\n      const redirects = nonHighlitghables.map(triggerId => ({\r\n        src: { layout: 'WITH_SPLIT_BAR', triggerId, showRight: false },\r\n        dest: { layout: 'FULL_CLIENT' }\r\n      }))\r\n      comToPlugin.postSetRedirects(redirects)\r\n\r\n      // Add click events on triggers\r\n      const clickTargets =\r\n        '.dcs-icons, .dcs-trigger.dcs-no-balloon .dcs-trigger-span, .dcs-trigger.dcs-no-balloon.dcs-no-span'\r\n      u.dom.forEach(document.querySelectorAll(clickTargets), node => {\r\n        node.onclick = e => {\r\n          // Don't do anything if user is selecting text\r\n          if (window.getSelection().toString()) {\r\n            return\r\n          }\r\n\r\n          const triggerNode = e.target.closest('.dcs-trigger')\r\n          const triggerId = triggerNode.dataset.dcsTriggerId\r\n\r\n          this._selectTriggers(triggerId)\r\n\r\n          comToPlugin.postSetDiscourseRoute({\r\n            route: {\r\n              layout: 'WITH_SPLIT_BAR',\r\n              pageName: triggerNode.dataset.dcsPageName || pageName,\r\n              triggerId,\r\n              interactMode: triggerNode.dataset.dcsInteractMode,\r\n              showRight: true\r\n            },\r\n            mode: 'PUSH',\r\n            clientContext: true\r\n          })\r\n\r\n          // Mandatory because we want our global click event to fire only\r\n          // when user clicks on an empty space\r\n          e.stopPropagation()\r\n        }\r\n      })\r\n\r\n      this.runReady = true\r\n\r\n      // Case click nowhere special (all Docuss specific events ar handles\r\n      // elsewhere with preventDefault)\r\n\r\n      window.addEventListener('click', () => {\r\n        if (\r\n          this.selTriggerNode &&\r\n          this.selTriggerNode.dataset.dcsHighlightable\r\n        ) {\r\n          this._selectTriggers(null)\r\n          comToPlugin.postSetDiscourseRoute({\r\n            route: { layout: 'FULL_CLIENT', pageName },\r\n            mode: 'PUSH',\r\n            clientContext: true\r\n          })\r\n        }\r\n      })\r\n\r\n      // Resize event with debounce\r\n      // https://developer.mozilla.org/en-US/docs/Web/Events/resize#setTimeout\r\n      window.addEventListener('resize', evt => {\r\n        if (this.resizeTimer !== null) {\r\n          clearTimeout(this.resizeTimer)\r\n        }\r\n        this.resizeTimer = setTimeout(() => {\r\n          this.resizeTimer = null\r\n          if (this.selTriggerNode) {\r\n            _scrollIntoViewIfNeeded(this.selTriggerNode)\r\n          }\r\n        }, 100)\r\n      })\r\n\r\n      if (this.delayedRoute) {\r\n        this._onDiscourseRoutePushed({ route: this.delayedRoute })\r\n      }\r\n    })\r\n  }\r\n\r\n  _onDiscourseRoutePushed({ route, descr, counts, clientContext }) {\r\n    // Case init\r\n    if (this.resolveInit) {\r\n      this.resolveInit({\r\n        descr,\r\n        pageName: route.pageName,\r\n        discourseUrl: route.url,\r\n        counts\r\n      })\r\n      delete this.resolveInit\r\n      this.runReady = false\r\n      this.delayedRoute = route\r\n      return\r\n    }\r\n\r\n    // Case we're still not ready\r\n    if (!this.runReady) {\r\n      this.delayedRoute = route\r\n      return\r\n    }\r\n\r\n    // Set the route category and title\r\n    if (route.layout === 'WITH_SPLIT_BAR') {\r\n      const triggerNode =\r\n        route.triggerId &&\r\n        document.querySelector(\r\n          `.dcs-trigger[data-dcs-trigger-id=\"${route.triggerId}\"]`\r\n        )\r\n      const category =\r\n        (triggerNode && triggerNode.dataset.dcsCategory) ||\r\n        document.documentElement.dataset.dcsCategory\r\n      const discourseTitle =\r\n        (triggerNode && triggerNode.dataset.dcsDiscourseTitle) ||\r\n        document.documentElement.dataset.dcsDiscourseTitle\r\n      comToPlugin.postSetRouteProps({ category, discourseTitle })\r\n    }\r\n\r\n    // clientContext === true means that this route changed has been\r\n    // triggered by us, so there is nothing more we need to do (because the\r\n    // trigger is already selected)\r\n    if (!clientContext) {\r\n      this._selectTriggers(route.triggerId)\r\n    }\r\n  }\r\n\r\n  // Remember there can be more than one trigger per triggerId\r\n  _selectTriggers(triggerId) {\r\n    if (!this.runReady) {\r\n      throw new Error('should be ready')\r\n    }\r\n\r\n    // Unselect everything\r\n    this.selTriggerNode = null\r\n    u.dom.forEach(document.getElementsByClassName('dcs-highlighted'), node =>\r\n      node.classList.remove('dcs-highlighted')\r\n    )\r\n\r\n    // Case there is nothing to select\r\n    if (!triggerId) {\r\n      return\r\n    }\r\n\r\n    // Look for the trigger node in the DOM\r\n    const triggerNodes = document.querySelectorAll(\r\n      `.dcs-trigger[data-dcs-trigger-id=\"${triggerId}\"]`\r\n    )\r\n\r\n    // Case tag not found\r\n    if (!triggerNodes.length) {\r\n      comToPlugin.postSetRouteProps({ error })\r\n      return\r\n    }\r\n\r\n    // Highlight the trigger and subsec nodes\r\n    u.dom.forEach(triggerNodes, node => {\r\n      if (node.dataset.dcsHighlightable) {\r\n        node.classList.add('dcs-highlighted')\r\n        const subsec = node.closest('.dcs-subsec')\r\n        subsec && subsec.classList.add('dcs-highlighted')\r\n      }\r\n    })\r\n\r\n    // Bring the first trigger node into view\r\n    // THIS IS REQUIRED WHEN LAYOUT HAS CHANGED, BUT ALSO WHEN USING THE BACK\r\n    // BUTTON TO A PREVIOUSLY SELECTED HEADING FAR AWAY\r\n    // Need a setTimeout, to ensure the layout change has occurred.\r\n    // 200 is the iframes animation duration + 30 for security\r\n    // +300 because some web sites (ex: VueJS API) have an animation when layout\r\n    // changes from narrow to wide screen.\r\n    this.selTriggerNode = triggerNodes[0]\r\n    setTimeout(() => _scrollIntoViewIfNeeded(this.selTriggerNode), 700)\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nfunction _scrollIntoViewIfNeeded(target) {\r\n  const rect = target.getBoundingClientRect()\r\n  // https://stackoverflow.com/a/22480938/3567351\r\n  const isPartiallyVisible = rect.top < window.innerHeight && rect.bottom >= 0\r\n  if (!isPartiallyVisible) {\r\n    target.scrollIntoView() // Set the element top to be at the top of the screen\r\n    window.scrollBy(0, -50) // Lower it a little bit\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nexport const htmlBased = new HtmlBased()\r\n\r\n//------------------------------------------------------------------------------\r\n","import { htmlBased } from './htmlBased'\r\n\r\nhtmlBased.connect({ discourseOrigin: '*', timeout: 10000 }).then(\r\n  args => {\r\n    htmlBased.parseDom(args)\r\n  },\r\n  e => logError('Unable to connect to dcs-discourse-plugin2', e)\r\n)\r\n"],"names":["u","inIFrame","window","self","top","e","dom","onDOMReady","Promise","resolve","document","readyState","addEventListener","[object Object]","nodeList","callback","scope","list","i","length","call","wrap","el","wrapper","parentNode","insertBefore","appendChild","elArray","copyArray","Array","prototype","slice","forEach","htmlString","div","createElement","innerHTML","trim","firstChild","BellhopEventDispatcher","_listeners","name","priority","this","_priority","parseInt","indexOf","push","sort","listenerSorter","a","b","index","splice","event","data","type","Bellhop","id","Math","random","connected","isChild","connecting","origin","_sendLater","iframe","receive","_this","bind","message","target","source","onConnectionReceived","JSON","parse","err","error","trigger","postMessage","send","disconnect","HTMLIFrameElement","supported","removeEventListener","stringify","runOnce","on","internalCallback","off","parent","contentWindow","comToPlugin","_bellhop","_timer","_onConnected","clearTimeout","discourseOrigin","onConnected","timeout","onTimeout","Error","setTimeout","connect","undefined","cb","route","mode","clientContext","arguments","hash","category","discourseTitle","redirects","_scrollIntoViewIfNeeded","rect","getBoundingClientRect","innerHeight","bottom","scrollIntoView","scrollBy","htmlBased","selTriggerNode","resizeTimer","onDiscourseRoutePushed","_onDiscourseRoutePushed","onCountsChanged","counts","console","log","reject","resolveInit","descr","pageName","discourseUrl","pageUrlWithoutProxy","staticPages","find","p","url","URL","then","getElementsByTagName","href","startsWith","getAttribute","substring","onclick","preventDefault","stopPropagation","postSetDiscourseRoute","layout","targetUrlNoHash","split","postSetHash","page","nodes","getElementsByClassName","ids","node","triggerId","dataset","dcsTriggerId","highlightable","dcsHighlightable","Object","keys","filter","map","src","showRight","dest","postSetRedirects","querySelectorAll","getSelection","toString","triggerNode","closest","_selectTriggers","dcsPageName","interactMode","dcsInteractMode","runReady","evt","delayedRoute","querySelector","dcsCategory","documentElement","dcsDiscourseTitle","postSetRouteProps","classList","remove","triggerNodes","add","subsec","args","parseDom","logError"],"mappings":"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"}