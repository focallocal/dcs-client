{"version":3,"file":"dcs-decorator.js","sources":["../src/utils.js","../node_modules/bellhop-iframe/src/BellhopEventDispatcher.js","../node_modules/bellhop-iframe/src/Bellhop.js","../src/comToPlugin.js","../src/htmlBased.js","../src/dcs-decorator.js"],"sourcesContent":["//------------------------------------------------------------------------------\r\n\r\nexport const u = {}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\n// Return true if we are in an iframe\r\n// https://stackoverflow.com/a/326076/3567351\r\nu.inIFrame = () => {\r\n  try {\r\n    return window.self !== window.top\r\n  } catch (e) {\r\n    return true\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nu.dom = {\r\n  // Resolve when DOM is ready\r\n  onDOMReady() {\r\n    return new Promise(resolve => {\r\n      if (document.readyState !== 'loading') {\r\n        resolve()\r\n      } else {\r\n        document.addEventListener('DOMContentLoaded', resolve)\r\n      }\r\n    })\r\n  },\r\n\r\n  // https://github.com/imagitama/nodelist-foreach-polyfill/blob/master/index.js\r\n  forEach(nodeList, callback, scope) {\r\n    // Duplicate the list, so that we can iterate over a dynamic node list\r\n    // returned by getElementsByClassName() and the likes. If we don't, the\r\n    // following won't work, as we change the list dynamically while we iterate\r\n    // over it:\r\n    // u.dom.forEach(document.getElementsByClassName('toto'), node => node.classList.remove('toto'))\r\n    const list = [...nodeList]\r\n    for (let i = 0; i < list.length; i++) {\r\n      callback.call(scope || window, list[i], i)\r\n    }\r\n  },\r\n\r\n  wrap(el, wrapper) {\r\n    el.parentNode.insertBefore(wrapper, el)\r\n    wrapper.appendChild(el)\r\n    return wrapper\r\n  },\r\n\r\n  wrapAll(elArray, wrapper) {\r\n    if (elArray && elArray.length) {\r\n      // Duplicate the array in case it is a DOM nodeList than would be modified\r\n      // while we move elements\r\n      const copyArray = Array.prototype.slice.call(elArray)\r\n      copyArray[0].parentNode.insertBefore(wrapper, copyArray[0])\r\n      copyArray.forEach(el => wrapper.appendChild(el))\r\n    }\r\n    return wrapper\r\n  },\r\n\r\n  createElement(htmlString) {\r\n    const div = document.createElement('div')\r\n    div.innerHTML = htmlString.trim()\r\n    return div.firstChild\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n","/**\n * Function with a added priority type\n * @typedef {Function} PriorityFunction\n * @property {number} _priority\n */\n\n/**\n * Generic event dispatcher\n * @class  BellhopEventDispatcher\n */\nexport class BellhopEventDispatcher {\n  /**\n   *  The collection of event listeners\n   *  @property {Object} _listeners\n   *  @private\n   */\n  constructor() {\n    this._listeners = {};\n  }\n\n  /**\n   *  Add an event listener to the listen to an event from either the parent or iframe\n   *  @method on\n   *  @param {String} name The name of the event to listen\n   *  @param {PriorityFunction} callback The handler when an event is triggered\n   *  @param {number} [priority=0] The priority of the event listener. Higher numbers are handled first.\n   */\n  on(name, callback, priority = 0) {\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n    callback._priority = parseInt(priority) || 0;\n\n    // If callback is already set to this event\n    if (-1 !== this._listeners[name].indexOf(callback)) {\n      return;\n    }\n\n    this._listeners[name].push(callback);\n\n    if (this._listeners[name].length > 1) {\n      this._listeners[name].sort(this.listenerSorter);\n    }\n  }\n\n  /**\n   * @private\n   * @param {PriorityFunction} a\n   * @param {PriorityFunction} b\n   * @returns {number};\n   *  Sorts listeners added by .on() by priority\n   */\n  listenerSorter(a, b) {\n    return a._priority - b._priority;\n  }\n\n  /**\n   *  Remove an event listener\n   *  @method off\n   *  @param {String} name The name of event to listen for. If undefined, remove all listeners.\n   *  @param {Function} [callback] The optional handler when an event is triggered, if no callback\n   *         is set then all listeners by type are removed\n   */\n  off(name, callback) {\n    if (this._listeners[name] === undefined) {\n      return;\n    }\n\n    if (callback === undefined) {\n      delete this._listeners[name];\n      return;\n    }\n\n    const index = this._listeners[name].indexOf(callback);\n\n    -1 < index ? this._listeners[name].splice(index, 1) : undefined;\n  }\n\n  /**\n   *  Trigger any event handlers for an event type\n   *  @method trigger\n   *  @param {object | String} event The event to send\n   *  @param {object} [data = {}] optional data to send to other areas in the app that are listening for this event\n   */\n  trigger(event, data = {}) {\n    if (typeof event == 'string') {\n      event = {\n        type: event,\n        data: 'object' === typeof data && null !== data ? data : {}\n      };\n    }\n\n    if ('undefined' !== typeof this._listeners[event.type]) {\n      for (let i = this._listeners[event.type].length - 1; i >= 0; i--) {\n        this._listeners[event.type][i](event);\n      }\n    }\n  }\n\n  /**\n   * Reset the listeners object\n   * @method  destroy\n   */\n  destroy() {\n    this._listeners = {};\n  }\n}\n","import { BellhopEventDispatcher } from './BellhopEventDispatcher.js';\n\n/**\n *  Abstract the communication layer between the iframe\n *  and the parent DOM\n *  @class Bellhop\n *  @extends BellhopEventDispatcher\n */\nexport class Bellhop extends BellhopEventDispatcher {\n  /**\n   * Creates an instance of Bellhop.\n   * @memberof Bellhop\n   * @param { string | number } id the id of the Bellhop instance\n   */\n  constructor(id = (Math.random() * 100) | 0) {\n    super();\n\n    /**\n     *  The instance ID for bellhop\n     *  @property {string} id\n     */\n    this.id = `BELLHOP:${id}`;\n    /**\n     *  If we are connected to another instance of the bellhop\n     *  @property {Boolean} connected\n     *  @readOnly\n     *  @default false\n     *  @private\n     */\n    this.connected = false;\n\n    /**\n     *  If this instance represents an iframe instance\n     *  @property {Boolean} isChild\n     *  @private\n     *  @default true\n     */\n    this.isChild = true;\n\n    /**\n     *  If we are current trying to connec\n     *  @property {Boolean} connecting\n     *  @default false\n     *  @private\n     */\n    this.connecting = false;\n\n    /**\n     *  If using cross-domain, the domain to post to\n     *  @property {string} origin\n     *  @private\n     *  @default \"*\"\n     */\n    this.origin = '*';\n\n    /**\n     *  Save any sends to wait until after we're done\n     *  @property {Array} _sendLater\n     *  @private\n     */\n    this._sendLater = [];\n\n    /**\n     * The iframe element\n     * @property {HTMLIFrameElement} iframe\n     * @private\n     * @readOnly\n     */\n    this.iframe = null;\n\n    /**\n     * The bound receive function\n     * @property {Function} receive\n     * @private\n     */\n    this.receive = this.receive.bind(this);\n  }\n\n  /**\n   *  The connection has been established successfully\n   *  @event connected\n   */\n\n  /**\n   *  Connection could not be established\n   *  @event failed\n   */\n\n  /**\n   *  Handle messages in the window\n   *  @method receive\n   *  @param { MessageEvent } message the post message received from another bellhop instance\n   *  @private\n   */\n  receive(message) {\n    // Ignore messages that don't originate from the target\n    // we're connected to\n    if (this.target !== message.source) {\n      return;\n    }\n\n    // If this is not the initial connection message\n    if (message.data !== 'connected') {\n      let data = message.data;\n      // Check to see if the data was sent as a stringified json\n      if ('string' === typeof data) {\n        try {\n          data = JSON.parse(data);\n        } catch (err) {\n          console.error('Bellhop error: ', err);\n        }\n      }\n      if (this.connected && 'object' === typeof data && data.type) {\n        this.trigger(data);\n      }\n      return;\n    }\n    // Else setup the connection\n    this.onConnectionReceived(message.data);\n  }\n  /**\n   * @memberof Bellhop\n   * @param {object} message the message received from the other bellhop instance\n   * @private\n   */\n  onConnectionReceived(message) {\n    this.connecting = false;\n    this.connected = true;\n\n    // Be polite and respond to the child that we're ready\n    if (!this.isChild) {\n      this.target.postMessage(message, this.origin);\n    }\n\n    // If we have any sends waiting to send\n    // we are now connected and it should be okay\n    for (let i = 0; i < this._sendLater.length; i++) {\n      const { type, data } = this._sendLater[i];\n      this.send(type, data);\n    }\n    this._sendLater.length = 0;\n\n    // If there is a connection event assigned call it\n    this.trigger('connected');\n  }\n\n  /**\n   *  Setup the connection\n   *  @method connect\n   *  @param {HTMLIFrameElement} iframe The iframe to communicate with. If no value is set, the assumption\n   *         is that we're the child trying to communcate with our window.parent\n   *  @param {String} [origin=\"*\"] The domain to communicate with if different from the current.\n   *  @return {Bellhop} Return instance of current object\n   */\n  connect(iframe, origin = '*') {\n    // Ignore if we're already trying to connect\n    if (this.connecting) {\n      return;\n    }\n\n    // Disconnect from any existing connection\n    this.disconnect();\n\n    // We are trying to connect\n    this.connecting = true;\n\n    // The iframe if we're the parent\n    if (iframe instanceof HTMLIFrameElement) {\n      this.iframe = iframe;\n    }\n\n    // The instance of bellhop is inside the iframe\n    this.isChild = iframe === undefined;\n\n    this.supported = true;\n    if (this.isChild) {\n      // for child pages, the window passed must be a different window\n      this.supported = window != iframe;\n    }\n\n    this.origin = origin;\n\n    window.addEventListener('message', this.receive);\n\n    if (this.isChild) {\n      // No parent, can't connect\n      if (window === this.target) {\n        this.trigger('failed');\n      } else {\n        // If connect is called after the window is ready\n        // we can go ahead and send the connect message\n        this.target.postMessage('connected', this.origin);\n      }\n    }\n  }\n\n  /**\n   *  Disconnect if there are any open connections\n   *  @method disconnect\n   */\n  disconnect() {\n    this.connected = false;\n    this.connecting = false;\n    this.origin = null;\n    this.iframe = null;\n    this.isChild = true;\n    this._sendLater.length = 0;\n\n    window.removeEventListener('message', this.receive);\n  }\n\n  /**\n   *  Send an event to the connected instance\n   *  @method send\n   *  @param {string} type name/type of the event\n   *  @param {*} [data = {}] Additional data to send along with event\n   */\n  send(type, data = {}) {\n    if (typeof type !== 'string') {\n      throw 'The event type must be a string';\n    }\n\n    const message = {\n      type,\n      data\n    };\n\n    if (this.connecting) {\n      this._sendLater.push(message);\n    } else {\n      this.target.postMessage(JSON.stringify(message), this.origin);\n    }\n  }\n\n  /**\n   *  A convenience method for sending and the listening to create\n   *  a singular link to fetching data. This is the same calling send\n   *  and then getting a response right away with the same event.\n   *  @method fetch\n   *  @param {String} event The name of the event\n   *  @param {Function} callback The callback to call after, takes event object as one argument\n   *  @param {Object} [data = {}] Optional data to pass along\n   *  @param {Boolean} [runOnce=false] If we only want to fetch once and then remove the listener\n   */\n  fetch(event, callback, data = {}, runOnce = false) {\n    if (!this.connecting && !this.connected) {\n      throw 'No connection, please call connect() first';\n    }\n\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n\n      callback(e);\n    };\n\n    this.on(event, internalCallback);\n    this.send(event, data);\n  }\n\n  /**\n   *  A convience method for listening to an event and then responding with some data\n   *  right away. Automatically removes the listener\n   *  @method respond\n   *  @param {String} event The name of the event\n   *  @param {Object | function} [data = {}] The object to pass back.\n   *  \tMay also be a function; the return value will be sent as data in this case.\n   *  @param {Boolean} [runOnce=false] If we only want to respond once and then remove the listener\n   */\n  respond(event, data = {}, runOnce = false) {\n    const internalCallback = e => {\n      if (runOnce) {\n        this.off(e.type, internalCallback);\n      }\n      this.send(event, 'function' === typeof data ? data() : data);\n    };\n    this.on(event, internalCallback);\n  }\n\n  /**\n   *  Destroy and don't user after this\n   *  @method destroy\n   */\n  destroy() {\n    super.destroy();\n    this.disconnect();\n    this._sendLater.length = 0;\n  }\n\n  /**\n   *\n   * Returns the correct parent element for Bellhop's context\n   * @readonly\n   * @memberof Bellhop\n   */\n  get target() {\n    return this.isChild ? window.parent : this.iframe.contentWindow;\n  }\n}\n","import * as comTypes from './com-types'\r\nimport { Bellhop } from 'bellhop-iframe'\r\nimport { u } from './utils'\r\n\r\nexport const inIFrame = u.inIFrame\r\n\r\nclass ComToPlugin {\r\n  //----------------------------------------------------------------------------\r\n\r\n  constructor() {\r\n    this._bellhop = new Bellhop()\r\n    this._timer = null\r\n    this._onConnected = null\r\n\r\n    // This is called avery time the iframe reloads\r\n    this._bellhop.on('connected', () => {\r\n      if (this._timer) {\r\n        clearTimeout(this._timer)\r\n        this._timer = null\r\n      }\r\n      this._onConnected && this._onConnected()\r\n    })\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @param {Object} arg\r\n   * @param {string} arg.discourseOrigin\r\n   * @param {OnConnectedCallback} arg.onConnected\r\n   * @param {number} arg.timeout\r\n   * @param {OnTimeoutCallback} arg.onTimeout\r\n   */\r\n  connect({ discourseOrigin, onConnected, timeout, onTimeout }) {\r\n    if (!u.inIFrame()) {\r\n      throw new Error('comToPlugin must be used in an iframe')\r\n    }\r\n    this.disconnect()\r\n    this._onConnected = onConnected\r\n    this._timer = timeout\r\n      ? setTimeout(() => {\r\n          onTimeout && onTimeout()\r\n        }, timeout)\r\n      : null\r\n    this._bellhop.connect(undefined, discourseOrigin)\r\n  }\r\n\r\n  disconnect() {\r\n    if (this._timer) {\r\n      clearTimeout(this._timer)\r\n      this._timer = null\r\n    }\r\n    this._bellhop.disconnect()\r\n  }\r\n\r\n  isConnected() {\r\n    return this._bellhop.connected\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @callback OnDiscourseRoutePushedCallback\r\n   * @param {RoutePushedParams}\r\n   */\r\n  /**\r\n   *  @param {OnDiscourseRoutePushedCallback} cb\r\n   */\r\n  onDiscourseRoutePushed(cb) {\r\n    this._bellhop.on('m2', e => cb(e.data))\r\n  }\r\n\r\n  /**\r\n   * @callback OnCountsChangedCallback\r\n   * @param {Counts}\r\n   */\r\n  /**\r\n   *  @param {OnCountsChangedCallback} cb\r\n   */\r\n  onCountsChanged(cb) {\r\n    this._bellhop.on('m3', e => cb(e.data))\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n\r\n  /**\r\n   * @param {SetRouteParams}\r\n   */\r\n  postSetDiscourseRoute({ route, mode, clientContext }) {\r\n    this._bellhop.send('m4', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {SetHashParams}\r\n   */\r\n  postSetHash({ hash, mode }) {\r\n    this._bellhop.send('m5', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {RouteProps} props\r\n   */\r\n  postSetRouteProps({ category, discourseTitle, error }) {\r\n    this._bellhop.send('m6', arguments[0])\r\n  }\r\n\r\n  /**\r\n   * @param {[Redirect]} redirects\r\n   */\r\n  postSetRedirects(redirects) {\r\n    this._bellhop.send('m7', redirects)\r\n  }\r\n\r\n  //----------------------------------------------------------------------------\r\n}\r\n\r\nexport const comToPlugin = new ComToPlugin()\r\n","import { u } from './utils'\r\nimport { comToPlugin } from './comToPlugin'\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nexport { u, comToPlugin }\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nclass HtmlBased {\r\n  constructor() {\r\n    this.selTriggerNode = null\r\n    this.resizeTimer = null\r\n    comToPlugin.onDiscourseRoutePushed(this._onDiscourseRoutePushed.bind(this))\r\n    comToPlugin.onCountsChanged(({ counts }) => console.log('counts: ', counts))\r\n  }\r\n\r\n  connect({ discourseOrigin, timeout }) {\r\n    return new Promise((resolve, reject) => {\r\n      // Establish communication with the Discourse plugin\r\n      this.resolveInit = resolve\r\n      comToPlugin.connect({\r\n        discourseOrigin,\r\n        timeout,\r\n        onTimeout: () => reject('timeout')\r\n      })\r\n    })\r\n  }\r\n\r\n  parseDom({ descr, pageName, discourseOrigin, counts }) {\r\n    // We will resolve all links to absolute without proxy (\"https://website.com/bar/index.html\")\r\n    // We start by retrieving the url of the current page url without the proxy\r\n    const page = descr.staticPages.find(p => p.name === pageName)\r\n    const pageUrlWithoutProxy = page.url\r\n\r\n    return u.dom.onDOMReady().then(() => {\r\n      // Modify the document links so that they open the correct url in the\r\n      // correct place\r\n      u.dom.forEach(document.getElementsByTagName('a'), a => {\r\n        // Case link is empty\r\n        if (!a.href || a.href === '#' || a.href.startsWith('javascript:')) {\r\n          return\r\n        }\r\n\r\n        // Clean the link, so that it's easier to handle later:\r\n        // - Replace the DISCOURSE placeholder by the full link\r\n        // - Convert from relative to absolute without proxy\r\n        // - Remove inappropriate target\r\n        const href = a.getAttribute('href').trim()\r\n        if (href.startsWith('DISCOURSE/')) {\r\n          a.href = discourseOrigin + href.substring('DISCOURSE/'.length - 1)\r\n        } else {\r\n          a.href = new URL(href, pageUrlWithoutProxy)\r\n        }\r\n        if (a.target === '_parent' || a.target === '_top') {\r\n          delete a.target\r\n        }\r\n\r\n        // Case the link is a discourse link: cancel the behavior and set a\r\n        // custom click handler\r\n        if (a.origin === discourseOrigin) {\r\n          a.onclick = e => {\r\n            e.preventDefault()\r\n            e.stopPropagation()\r\n            comToPlugin.postSetDiscourseRoute({\r\n              route: { layout: 1, pathname: a.pathname },\r\n              mode: 'PUSH',\r\n              clientContext: true\r\n            })\r\n          }\r\n          return\r\n        }\r\n\r\n        const targetUrlNoHash = a.href.split('#')[0]\r\n\r\n        // Case it is an anchor (internal link)\r\n        if (a.hash && targetUrlNoHash === pageUrlWithoutProxy.split('#')[0]) {\r\n          // We need to notify the parent window AND keep the default anchor behavior\r\n          a.onclick = () => {\r\n            comToPlugin.postSetHash({ hash: a.hash, mode: 'REPLACE' })\r\n          }\r\n          return\r\n        }\r\n\r\n        // Case it is an external link or a link to self\r\n\r\n        // See if there is a corresponding page in the website\r\n        const page = descr.staticPages.find(\r\n          p => p.url.split('#')[0] === targetUrlNoHash\r\n        )\r\n\r\n        // Case the external link points to an arbitrary external target (no\r\n        // page found)\r\n        if (!page) {\r\n          if (!a.target || a.target === '_self') {\r\n            a.target = '_parent'\r\n          }\r\n          return\r\n        }\r\n\r\n        // Case the external link points to another page of the website (or\r\n        // to self)\r\n\r\n        // Change the href so that cmd+click or right click+... will open\r\n        // the Discourse instance in another tab\r\n        a.href = discourseOrigin + '/docuss/' + page.name + a.hash\r\n\r\n        // Regarding the simple click, cancel the default behavior and\r\n        // let Discourse load the target page\r\n        if (!a.target || a.target === '_self') {\r\n          a.onclick = e => {\r\n            e.preventDefault()\r\n            e.stopPropagation()\r\n            comToPlugin.postSetDiscourseRoute({\r\n              route: { layout: 0, pageName: page.name },\r\n              mode: 'PUSH',\r\n              clientContext: true\r\n            })\r\n          }\r\n        }\r\n      })\r\n\r\n      // Set the additional redirects\r\n      // Remember that a same triggerId can have several node with different\r\n      // dcsHighlightable property value. So we consider a trigger as\r\n      // highligthable if any of its nodes is highligthable\r\n      const nodes = document.getElementsByClassName('dcs-trigger')\r\n      const ids = {}\r\n      u.dom.forEach(nodes, node => {\r\n        const triggerId = node.dataset.dcsTriggerId\r\n        const highlightable = ids[triggerId] || !!node.dataset.dcsHighlightable\r\n        ids[triggerId] = highlightable\r\n      })\r\n      const nonHighlitghables = Object.keys(ids).filter(id => !ids[id])\r\n      // Here you might be tempted, if there are only nonHighlitghables\r\n      // triggers in the page, to set a single generic redirect instead of one\r\n      // redirect per trigger. Don't do that. Imagine the consequence if the\r\n      // page already contains a static redirect for full page commenting\r\n      // (WITH_SPLIT_BAR => FULL_CLIENT). Yep, infinite loop.\r\n      const redirects = nonHighlitghables.map(triggerId => ({\r\n        src: { layout: 2, triggerId },\r\n        dest: { layout: 0, pageName: '@SAME_AS_SRC@' }\r\n      }))\r\n      comToPlugin.postSetRedirects(redirects)\r\n\r\n      // Add click events on triggers\r\n      const clickTargets =\r\n        '.dcs-icons, .dcs-trigger.dcs-no-balloon .dcs-trigger-span, .dcs-trigger.dcs-no-balloon.dcs-no-span'\r\n      u.dom.forEach(document.querySelectorAll(clickTargets), node => {\r\n        node.onclick = e => {\r\n          // Don't do anything if user is selecting text\r\n          if (window.getSelection().toString()) {\r\n            return\r\n          }\r\n\r\n          const triggerNode = e.target.closest('.dcs-trigger')\r\n          const triggerId = triggerNode.dataset.dcsTriggerId\r\n\r\n          this._selectTriggers(triggerId)\r\n\r\n          comToPlugin.postSetDiscourseRoute({\r\n            route: {\r\n              layout: 3,\r\n              pageName: triggerNode.dataset.dcsPageName || pageName,\r\n              triggerId,\r\n              interactMode: triggerNode.dataset.dcsInteractMode\r\n            },\r\n            mode: 'PUSH',\r\n            clientContext: true\r\n          })\r\n\r\n          // Mandatory because we want our global click event to fire only\r\n          // when user clicks on an empty space\r\n          e.stopPropagation()\r\n        }\r\n      })\r\n\r\n      this.runReady = true\r\n\r\n      // Case click nowhere special (all Docuss specific events ar handles\r\n      // elsewhere with preventDefault)\r\n\r\n      window.addEventListener('click', () => {\r\n        if (\r\n          this.selTriggerNode &&\r\n          this.selTriggerNode.dataset.dcsHighlightable\r\n        ) {\r\n          this._selectTriggers(null)\r\n          comToPlugin.postSetDiscourseRoute({\r\n            route: { layout: 0, pageName },\r\n            mode: 'PUSH',\r\n            clientContext: true\r\n          })\r\n        }\r\n      })\r\n\r\n      // Resize event with debounce\r\n      // https://developer.mozilla.org/en-US/docs/Web/Events/resize#setTimeout\r\n      window.addEventListener('resize', evt => {\r\n        if (this.resizeTimer !== null) {\r\n          clearTimeout(this.resizeTimer)\r\n        }\r\n        this.resizeTimer = setTimeout(() => {\r\n          this.resizeTimer = null\r\n          if (this.selTriggerNode) {\r\n            _scrollIntoViewIfNeeded(this.selTriggerNode)\r\n          }\r\n        }, 100)\r\n      })\r\n\r\n      if (this.delayedRoute) {\r\n        this._onDiscourseRoutePushed({ route: this.delayedRoute })\r\n      }\r\n    })\r\n  }\r\n\r\n  _onDiscourseRoutePushed({ route, descr, counts, clientContext, origin }) {\r\n    // Case init\r\n    if (this.resolveInit) {\r\n      this.resolveInit({\r\n        descr,\r\n        pageName: route.pageName,\r\n        discourseOrigin: origin,\r\n        counts\r\n      })\r\n      delete this.resolveInit\r\n      this.runReady = false\r\n      this.delayedRoute = route\r\n      return\r\n    }\r\n\r\n    // Case we're still not ready\r\n    if (!this.runReady) {\r\n      this.delayedRoute = route\r\n      return\r\n    }\r\n\r\n    // Set the route category and title\r\n    if (route.layout === 2 || route.layout === 3) {\r\n      const triggerNode =\r\n        route.triggerId &&\r\n        document.querySelector(\r\n          `.dcs-trigger[data-dcs-trigger-id=\"${route.triggerId}\"]`\r\n        )\r\n      const category =\r\n        (triggerNode && triggerNode.dataset.dcsCategory) ||\r\n        document.documentElement.dataset.dcsCategory\r\n      const discourseTitle =\r\n        (triggerNode && triggerNode.dataset.dcsDiscourseTitle) ||\r\n        document.documentElement.dataset.dcsDiscourseTitle\r\n      comToPlugin.postSetRouteProps({ category, discourseTitle })\r\n    }\r\n\r\n    // clientContext === true means that this route changed has been\r\n    // triggered by us, so there is nothing more we need to do (because the\r\n    // trigger is already selected)\r\n    if (!clientContext) {\r\n      this._selectTriggers(route.triggerId)\r\n    }\r\n  }\r\n\r\n  // Remember there can be more than one trigger per triggerId\r\n  _selectTriggers(triggerId) {\r\n    if (!this.runReady) {\r\n      throw new Error('should be ready')\r\n    }\r\n\r\n    // Unselect everything\r\n    this.selTriggerNode = null\r\n    u.dom.forEach(document.getElementsByClassName('dcs-highlighted'), node =>\r\n      node.classList.remove('dcs-highlighted')\r\n    )\r\n\r\n    // Case there is nothing to select\r\n    if (!triggerId) {\r\n      return\r\n    }\r\n\r\n    // Look for the trigger node in the DOM\r\n    const triggerNodes = document.querySelectorAll(\r\n      `.dcs-trigger[data-dcs-trigger-id=\"${triggerId}\"]`\r\n    )\r\n\r\n    // Case tag not found\r\n    if (!triggerNodes.length) {\r\n      comToPlugin.postSetRouteProps({ error })\r\n      return\r\n    }\r\n\r\n    // Highlight the trigger and subsec nodes\r\n    u.dom.forEach(triggerNodes, node => {\r\n      if (node.dataset.dcsHighlightable) {\r\n        node.classList.add('dcs-highlighted')\r\n        const subsec = node.closest('.dcs-subsec')\r\n        subsec && subsec.classList.add('dcs-highlighted')\r\n      }\r\n    })\r\n\r\n    // Bring the first trigger node into view\r\n    // THIS IS REQUIRED WHEN LAYOUT HAS CHANGED, BUT ALSO WHEN USING THE BACK\r\n    // BUTTON TO A PREVIOUSLY SELECTED HEADING FAR AWAY\r\n    // Need a setTimeout, to ensure the layout change has occurred.\r\n    // 200 is the iframes animation duration + 30 for security\r\n    // +300 because some web sites (ex: VueJS API) have an animation when layout\r\n    // changes from narrow to wide screen.\r\n    this.selTriggerNode = triggerNodes[0]\r\n    setTimeout(() => _scrollIntoViewIfNeeded(this.selTriggerNode), 700)\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nfunction _scrollIntoViewIfNeeded(target) {\r\n  const rect = target.getBoundingClientRect()\r\n  // https://stackoverflow.com/a/22480938/3567351\r\n  const isPartiallyVisible = rect.top < window.innerHeight && rect.bottom >= 0\r\n  if (!isPartiallyVisible) {\r\n    target.scrollIntoView() // Set the element top to be at the top of the screen\r\n    window.scrollBy(0, -50) // Lower it a little bit\r\n  }\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nexport const htmlBased = new HtmlBased()\r\n\r\n//------------------------------------------------------------------------------\r\n","import { u } from './utils'\r\nimport { htmlBased } from './htmlBased'\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nif (u.inIFrame()) {\r\n  console.log('Docuss Decorator - Initializing...')\r\n  htmlBased\r\n    .connect({ discourseOrigin: '*', timeout: 10000 })\r\n    .then(args => modifyDom(args))\r\n    .then(args => htmlBased.parseDom(args))\r\n    .catch(e => {\r\n      if (typeof e === 'string') {\r\n        console.log('Docuss Decorator Error - ' + e)\r\n      } else {\r\n        throw e\r\n      }\r\n    })\r\n} else {\r\n  console.log(\r\n    'Docuss Decorator - Could not run, as the page is not displayed in a Docuss iframe'\r\n  )\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nlet dcsTagSettings = null\r\n\r\nfunction modifyDom({ descr, pageName, discourseOrigin, counts }) {\r\n  // If no decorator, quit\r\n  const decorator = descr.clientData && descr.clientData.decorator\r\n  if (!decorator) {\r\n    throw 'No decorator found in json descriptor'\r\n  }\r\n\r\n  // Keep the tag settings\r\n  dcsTagSettings = descr.dcsTag\r\n\r\n  // Insert the additional CSS\r\n  const injectCss = (decorator.injectCss || []).reduce((res, a) => {\r\n    return includes(pageName, a.pageNames) ? res.concat(a.css) : res\r\n  }, [])\r\n  if (injectCss.length) {\r\n    const css = document.createElement('style')\r\n    css.type = 'text/css'\r\n    css.innerHTML = injectCss.join('\\n')\r\n    document.head.appendChild(css)\r\n  }\r\n\r\n  // Insert the global markup\r\n  const allProps = decorator.pageProperties || []\r\n  const pageProps = allProps.filter(p => includes(pageName, p.pageNames)).pop()\r\n  const category = (pageProps && pageProps.category) || decorator.category\r\n  const discourseTitle =\r\n    (pageProps && pageProps.discourseTitle) || decorator.discourseTitle\r\n  if (category) {\r\n    document.documentElement.dataset.dcsCategory = category\r\n  }\r\n  if (discourseTitle) {\r\n    document.documentElement.dataset.dcsDiscourseTitle = discourseTitle\r\n  }\r\n\r\n  // Insert the triggers' markup\r\n  const allTriggers = decorator.injectTriggers || []\r\n  const pageTriggers = allTriggers.filter(t => includes(pageName, t.pageNames))\r\n  const pageCounts = counts.filter(c => c.pageName === pageName)\r\n  return u.dom.onDOMReady().then(() => {\r\n    injectTriggers(pageTriggers, pageCounts)\r\n    console.log('Docuss Decorator - Ready')\r\n    return { descr, pageName, discourseOrigin, counts }\r\n  })\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nlet htmlIds\r\nlet htmlIdsNotFound\r\n\r\nfunction injectTriggers(triggers, counts) {\r\n  // Check if the page already contains Docuss markup\r\n  const dcsMarkup = !!document.querySelectorAll(\r\n    '.dcs-subsec, .dcs-trigger, .dcs-icons, .dcs-badge'\r\n  )\r\n  if (dcsMarkup.length) {\r\n    throw 'The page already contains Docuss markup'\r\n  }\r\n\r\n  htmlIdsNotFound = []\r\n\r\n  // Pre-fill the html ids with the non-html ids, to indicate they are reserved\r\n  htmlIds = triggers.reduce(\r\n    (res, t) => (Array.isArray(t.ids) ? res.concat(t.ids) : res),\r\n    []\r\n  )\r\n\r\n  triggers.forEach(trigger => addSubsections(trigger, counts))\r\n\r\n  if (htmlIdsNotFound.length) {\r\n    console.log(\r\n      'Docuss Decorator Warning - Those triggers with id=\"GENERATE_FROM_HTML_ID\" were assigned generated ids because no html id was found:',\r\n      htmlIdsNotFound\r\n    )\r\n  }\r\n}\r\n\r\nfunction addSubsections(trigger, counts) {\r\n  // Case there are no subsections\r\n  if (!trigger.ui.subsection) {\r\n    addTrigger(trigger, null, counts)\r\n    return\r\n  }\r\n\r\n  // Case there are subsections\r\n  const s = trigger.ui.subsection\r\n\r\n  // Get the beginning nodes\r\n  const beginNodes = document.querySelectorAll(s.begin)\r\n  if (!beginNodes.length) {\r\n    console.log(\r\n      `Docuss Decorator Warning - Found nothing with begin=\"${s.begin}\"`\r\n    )\r\n  }\r\n\r\n  // Go through the subsecs\r\n  u.dom.forEach(beginNodes, bn => {\r\n    while (\r\n      bn.parentNode &&\r\n      bn.parentNode.querySelectorAll(s.begin).length === 1 &&\r\n      (!s.end || bn.parentNode.querySelectorAll(s.end).length === 0)\r\n    ) {\r\n      bn = bn.parentNode\r\n    }\r\n\r\n    // We create the subsection by picking beginNode and its following\r\n    // siblings until we reach beginSubsecSelector or endSubsecSelector\r\n    const endSelector = s.begin + (s.end ? ',' + s.end : '')\r\n    const subsecNodes = [bn]\r\n    let sibling = bn.nextSibling\r\n    while (sibling) {\r\n      if (\r\n        sibling.nodeType === 1 &&\r\n        (sibling.matches(endSelector) ||\r\n          sibling.querySelectorAll(endSelector).length)\r\n      ) {\r\n        break\r\n      }\r\n      subsecNodes.push(sibling)\r\n      sibling = sibling.nextSibling\r\n    }\r\n\r\n    // Create the subsec div\r\n    const subsecWrapper = document.createElement('div')\r\n    subsecWrapper.classList.add('dcs-subsec')\r\n    u.dom.wrapAll(subsecNodes, subsecWrapper)\r\n\r\n    // Add included cssSelector\r\n    addTrigger(trigger, subsecWrapper, counts)\r\n  })\r\n}\r\n\r\nfunction addTrigger(trigger, subsecNode, counts) {\r\n  const target = subsecNode || document\r\n  const triggerNodes = target.querySelectorAll(trigger.ui.cssSelector)\r\n  u.dom.forEach(triggerNodes, (node, index) => {\r\n    // Compute the triggerId\r\n    let triggerId\r\n    if (trigger.ids[0] === 'GENERATE_FROM_HTML_ID') {\r\n      triggerId = getHtmlId(node, subsecNode)\r\n    } else if (trigger.ids[0] === 'GENERATE') {\r\n      triggerId = getHtmlId(null, null)\r\n    } else {\r\n      triggerId = trigger.ids[index % trigger.ids.length]\r\n    }\r\n\r\n    // Store the data as DOM params. We do this instead of attaching the trigger\r\n    // object to the DOM node for 2 reasons:\r\n    // 1. Remember that the triggerId is not associated with a single trigger\r\n    // descriptor, but with a single node out of the many corresponding to a\r\n    // trigger descriptor.\r\n    // 2. We want developers to be able to use the docuss click handler without\r\n    // the decorator code, by adding the Docuss html markup by hand.\r\n    node.dataset.dcsTriggerId = triggerId\r\n    node.dataset.dcsInteractMode = trigger.interactMode\r\n    if (trigger.category) {\r\n      node.dataset.dcsCategory = trigger.category\r\n    }\r\n    if (trigger.discourseTitle) {\r\n      node.dataset.dcsDiscourseTitle = trigger.discourseTitle\r\n    }\r\n    if (trigger.ui.highlightable) {\r\n      node.dataset.dcsHighlightable = true\r\n    }\r\n\r\n    // Add the docuss class to the trigger. DO THIS AFTER LOOKING FOR THE HTML\r\n    // ID, as the dcs-trigger serves as a flag\r\n    node.classList.add('dcs-trigger')\r\n\r\n    // If required, insert span nodes around text parts\r\n    // See: https://stackoverflow.com/a/10730777/3567351\r\n    if (trigger.ui.insertTextSpan) {\r\n      /*\r\n      const span = document.createElement('span')\r\n      subsecWrapper.classList.add('dcs-trigger-span')\r\n      u.dom.wrapAll(tn.childNodes, span)\r\n      */\r\n      const w = document.createTreeWalker(\r\n        node,\r\n        NodeFilter.SHOW_TEXT,\r\n        null,\r\n        false\r\n      )\r\n      let textNode\r\n      while ((textNode = w.nextNode())) {\r\n        if (textNode.data.trim()) {\r\n          u.dom.wrap(\r\n            textNode,\r\n            u.dom.createElement('<span class=\"dcs-trigger-span\"></span>')\r\n          )\r\n        }\r\n      }\r\n    } else {\r\n      node.classList.add('dcs-no-span')\r\n    }\r\n\r\n    // Add the orange balloon icon if needed\r\n    let iconsHtml = ''\r\n    if (trigger.ui.insertBalloon) {\r\n      iconsHtml += '<div class=\"dcs-balloon\"></div>'\r\n    } else {\r\n      node.classList.add('dcs-no-balloon')\r\n    }\r\n\r\n    // Add the count badge icon if needed\r\n    if (trigger.ui.insertCountBadge) {\r\n      const record = counts.find(r => r.triggerId === triggerId)\r\n      if (record && record.count !== 0) {\r\n        iconsHtml += ` \r\n        <div class=\"dcs-badge\" title=\"This section has ${\r\n          record.count\r\n        } topic(s)\">\r\n          ${record.count}\r\n        </div>\r\n      `\r\n      }\r\n    }\r\n\r\n    // Add the icons to the DOM\r\n    if (iconsHtml) {\r\n      node.appendChild(\r\n        u.dom.createElement(`\r\n        <span class=\"dcs-icons\" title=\"Click to discuss this subsection\">\r\n          ${iconsHtml}\r\n        </span>\r\n      `)\r\n      )\r\n    }\r\n  })\r\n}\r\n\r\nfunction getHtmlId(triggerNode, subsecNode) {\r\n  // Get the closest htmlId\r\n  // TEMPORARY TRICK: when triggerNode is null, we'll just generate an\r\n  // id not based on an html id\r\n  let beforeClean = triggerNode && findHtmlId(triggerNode, subsecNode)\r\n\r\n  // If no html id is found, generate a default one\r\n  if (!beforeClean) {\r\n    beforeClean = `gen${htmlIdsNotFound.length}`\r\n    htmlIdsNotFound.push({\r\n      Text: triggerNode.innerText.trim(),\r\n      'Generated Id': beforeClean\r\n    })\r\n  }\r\n\r\n  // Generate an htmlId compatible with a lowercase 20 characters Discourse tag\r\n  let afterClean = cleanTriggerId(beforeClean)\r\n\r\n  // Check for htmlId duplicates after truncation\r\n  if (htmlIds.includes(afterClean)) {\r\n    const maxLength = dcsTagSettings.maxTriggerIdLength\r\n    const save = afterClean\r\n    for (let i = 1; ; ++i) {\r\n      const iStr = i.toString()\r\n      if (iStr.length > maxLength) {\r\n        throw new Error('too many duplicated html ids')\r\n      }\r\n      const truncated = save.substring(0, maxLength - iStr.length)\r\n      afterClean = truncated + iStr\r\n      if (!htmlIds.includes(afterClean)) {\r\n        break\r\n      }\r\n    }\r\n  }\r\n\r\n  // Store the id for later deduplication\r\n  htmlIds.push(afterClean)\r\n\r\n  return afterClean\r\n}\r\n\r\nfunction findHtmlId(triggerNode, subsecNode) {\r\n  // First candidate is the node id\r\n  if (triggerNode.id) {\r\n    return triggerNode.id\r\n  }\r\n\r\n  // Second candidate is the id of a child element of the trigger\r\n  const nodesWithId = triggerNode.querySelectorAll('[id]:not([id=\"\"])')\r\n  if (nodesWithId.length) {\r\n    return nodesWithId[0].id\r\n  }\r\n\r\n  // Third candidate is the id of a parent that doesn't already contains a\r\n  // trigger. This allows to go back the DOM tree and find sections containing\r\n  // many headings, like in OpenSTack docs.\r\n  let parent = triggerNode.parentElement\r\n  while (parent) {\r\n    if (parent.getElementsByClassName('dcs-trigger').length) {\r\n      break\r\n    }\r\n    if (parent.id) {\r\n      return parent.id\r\n    }\r\n    parent = parent.parentElement\r\n  }\r\n\r\n  // Fourth candidate is any id in the subsec\r\n  if (subsecNode) {\r\n    const subsecNodesWithId = subsecNode.querySelectorAll('[id]:not([id=\"\"])')\r\n    if (subsecNodesWithId.length) {\r\n      return subsecNodesWithId[0].id\r\n    }\r\n  }\r\n\r\n  return null\r\n}\r\n\r\n//------------------------------------------------------------------------------\r\n\r\nfunction includes(pageName, pageNames) {\r\n  return pageNames[0] === '*' || pageNames.includes(pageName)\r\n}\r\n\r\nconst TAG_REPLACE_REGEX = /[^0-9A-Za-z_]/g\r\n\r\nfunction cleanTriggerId(triggerId) {\r\n  const res = triggerId\r\n    .substring(0, dcsTagSettings.maxTriggerIdLength)\r\n    .replace(TAG_REPLACE_REGEX, '_')\r\n  return dcsTagSettings.forceLowercase ? res.toLowerCase() : res\r\n}\r\n"],"names":["u","inIFrame","window","self","top","e","dom","onDOMReady","Promise","resolve","document","readyState","addEventListener","[object Object]","nodeList","callback","scope","list","i","length","call","wrap","el","wrapper","parentNode","insertBefore","appendChild","elArray","copyArray","Array","prototype","slice","forEach","htmlString","div","createElement","innerHTML","trim","firstChild","BellhopEventDispatcher","_listeners","name","priority","this","_priority","parseInt","indexOf","push","sort","listenerSorter","a","b","index","splice","event","data","type","Bellhop","id","Math","random","connected","isChild","connecting","origin","_sendLater","iframe","receive","_this","bind","message","target","source","onConnectionReceived","JSON","parse","err","error","trigger","postMessage","send","disconnect","HTMLIFrameElement","supported","removeEventListener","stringify","runOnce","on","internalCallback","off","parent","contentWindow","comToPlugin","_bellhop","_timer","_onConnected","clearTimeout","discourseOrigin","onConnected","timeout","onTimeout","Error","setTimeout","connect","undefined","cb","route","mode","clientContext","arguments","hash","category","discourseTitle","redirects","_scrollIntoViewIfNeeded","rect","getBoundingClientRect","innerHeight","bottom","scrollIntoView","scrollBy","htmlBased","selTriggerNode","resizeTimer","onDiscourseRoutePushed","_onDiscourseRoutePushed","onCountsChanged","counts","console","log","reject","resolveInit","descr","pageName","pageUrlWithoutProxy","staticPages","find","p","url","then","getElementsByTagName","href","startsWith","getAttribute","substring","URL","onclick","preventDefault","stopPropagation","postSetDiscourseRoute","layout","pathname","targetUrlNoHash","split","postSetHash","page","nodes","getElementsByClassName","ids","node","triggerId","dataset","dcsTriggerId","highlightable","dcsHighlightable","Object","keys","filter","map","src","dest","postSetRedirects","querySelectorAll","getSelection","toString","triggerNode","closest","_selectTriggers","dcsPageName","interactMode","dcsInteractMode","runReady","evt","delayedRoute","querySelector","dcsCategory","documentElement","dcsDiscourseTitle","postSetRouteProps","classList","remove","triggerNodes","add","subsec","args","decorator","clientData","dcsTagSettings","dcsTag","injectCss","reduce","res","includes","pageNames","concat","css","join","head","pageProps","pageProperties","pop","pageTriggers","injectTriggers","t","pageCounts","c","triggers","htmlIdsNotFound","htmlIds","isArray","ui","subsection","addTrigger","s","beginNodes","begin","bn","end","endSelector","subsecNodes","sibling","nextSibling","nodeType","matches","subsecWrapper","wrapAll","addSubsections","modifyDom","parseDom","catch","subsecNode","cssSelector","getHtmlId","insertTextSpan","w","createTreeWalker","NodeFilter","SHOW_TEXT","textNode","nextNode","iconsHtml","insertBalloon","insertCountBadge","record","r","count","beforeClean","nodesWithId","parentElement","subsecNodesWithId","findHtmlId","Text","innerText","Generated Id","afterClean","maxTriggerIdLength","replace","TAG_REPLACE_REGEX","forceLowercase","toLowerCase","cleanTriggerId","maxLength","save","iStr"],"mappings":"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"}